// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#include "UnrealEd.h"
#include "RawMesh.h"
#include "MeshUtilities.h"
#include "MaterialUtilities.h"

// Standard Simplygon channels have some issues with extracting color data back from simplification, 
// so we use this workaround with user channels
static const char* USER_MATERIAL_CHANNEL_METALLIC = "UserMetallic";
static const char* USER_MATERIAL_CHANNEL_ROUGHNESS = "UserRoughness";
static const char* USER_MATERIAL_CHANNEL_SPECULAR = "UserSpecular";

//@third party code BEGIN SIMPLYGON
#define USE_USER_OPACITY_CHANNEL 1
#if USE_USER_OPACITY_CHANNEL
static const char* USER_MATERIAL_CHANNEL_OPACITY = "UserOpacity";
#endif
static const char* USER_MATERIAL_CHANNEL_AO = "UserAO";
//@third party code END SIMPLYGON
static const TCHAR* SG_UE_INTEGRATION_REV = TEXT("@387");

#ifdef __clang__
// SimplygonSDK.h uses 'deprecated' pragma which Clang does not recognize
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-pragmas"	// warning : unknown pragma ignored [-Wunknown-pragmas]
#endif

#include "SimplygonSDK.h"


#ifdef __clang__
#pragma clang diagnostic pop
#endif

#include "MeshBoneReduction.h"
#include "ComponentReregisterContext.h"
//@third party code BEGIN SIMPLYGON
#include "ImageUtils.h"

#include "Developer/SimplygonUtilities/Public/SimplygonUtilities.h"

// Notes about IChartAggregator:
// - Available since Simplygon 7.0 (defined(SIMPLYGONSDK_VERSION) && SIMPLYGONSDK_VERSION >= 0x700).
// - Use of pure IChartAggregator will re-introduce bugs with UVs outside of 0..1 range, so UVs should
//   be scaled.
// - IChartAggregator probably needs more settings to be provided, because it will grow number of mesh
//   vertices a lot (up to 3x of mesh face count).
#define USE_SIMPLYGON_CHART_AGGREGATOR 0

// Use Engine's FLayoutUV class to generate non-overlapping texture coordinates. If disabled, Simplygon
// will be used.
#define USE_FLAYOUT_UV 1

static const char* GetSimplygonMaterialChannel(ESimplygonMaterialChannel::Type channel)
{

	if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_BASECOLOR)
		return SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR;
	else if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_SPECULAR)
		return SimplygonSDK::SG_MATERIAL_CHANNEL_SPECULAR;
	else if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_ROUGHNESS)
		return SimplygonSDK::SG_MATERIAL_CHANNEL_ROUGHNESS;
	else if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_METALLIC)
		return SimplygonSDK::SG_MATERIAL_CHANNEL_METALLIC;
	else if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_NORMALS)
		return SimplygonSDK::SG_MATERIAL_CHANNEL_NORMALS;
	else if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_OPACITY)
#if USE_USER_OPACITY_CHANNEL
		return USER_MATERIAL_CHANNEL_OPACITY;
#else
		return SimplygonSDK::SG_MATERIAL_CHANNEL_OPACITY;
#endif
	else if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_EMISSIVE)
		return SimplygonSDK::SG_MATERIAL_CHANNEL_EMISSIVE;
	else if (channel == ESimplygonMaterialChannel::SG_MATERIAL_CHANNEL_AO)
		return USER_MATERIAL_CHANNEL_AO;
	else
		return SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR;

}


//#define DEBUG_PROXY_MESH
//@third party code END SIMPLYGON

#define LOCTEXT_NAMESPACE "SimplygonMeshReduction"

class FSimplygonMeshReductionModule : public ISimplygonModule, public IModularFeature
{
public:
	// IModuleInterface interface.
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

	// IMeshReductionModule interface.
	virtual class IMeshReduction* GetMeshReductionInterface() override;
	virtual class IMeshMerging* GetMeshMergingInterface() override;
	//@third party code BEGIN SIMPLYGON 
	virtual class IMeshMaterialReduction* GetMeshMaterialReductionInterface() override;
	//@third party code END SIMPLYGON
private:
};


DEFINE_LOG_CATEGORY_STATIC(LogSimplygon, Log, All);
IMPLEMENT_MODULE(FSimplygonMeshReductionModule, SimplygonMeshReduction);

#define SIMPLYGON_COLOR_CHANNEL "VertexColors"

/** Receives error messages generated by Simplygon. These errors are presented via a message box. */
class FDefaultErrorHandler : public SimplygonSDK::rerrorhandler
{
public:
	virtual void HandleError(
		SimplygonSDK::IObject* Object,
		const char* InterfaceName,
		const char* MethodName,
		SimplygonSDK::rid ErrorType,
		const char* ErrorText)
	{
		FString ErrorString = FString::Printf(TEXT("Simplygon Error:\n\nInterface: %s\nMethod: %s\nError: (%d) %s"),
			ANSI_TO_TCHAR(InterfaceName),
			ANSI_TO_TCHAR(MethodName),
			ErrorType,
			ANSI_TO_TCHAR(ErrorText)
			);
		UE_LOG(LogSimplygon, Log, TEXT("%s"), *ErrorString);
		//FMessageDialog::Open(EAppMsgType::Ok, *ErrorString);
	}
};

/** Receives progress events from Simplygon and updates the status window. */
class FDefaultEventHandler : public SimplygonSDK::robserver
{
public:

	FDefaultEventHandler() : Task(nullptr), PreviousProgress(0) {}
	FScopedSlowTask* Task;

	int32 PreviousProgress;

	virtual void Execute(
		SimplygonSDK::IObject* Object,
		SimplygonSDK::rid EventId,
		void* EventParameterBlock,
		unsigned int EventParameterBlockSize)
	{
		if (EventId == SimplygonSDK::SG_EVENT_PROGRESS)
		{
			check(sizeof(int32) == EventParameterBlockSize);
			int32 ProgressPercent = *((int32*)EventParameterBlock);

			if (!IsInGameThread())
			{
				// Protection against execution of this callback from non-game thread.
				UE_LOG(LogSimplygon, Warning, TEXT("FDefaultEventHandler called from non-game thread. Progress is %d%%."), ProgressPercent);
			}
			else
			{
				if (Task != nullptr)
				{
					Task->EnterProgressFrame(ProgressPercent - PreviousProgress);
					PreviousProgress = ProgressPercent;
				}
				else
				{
					GWarn->UpdateProgress(ProgressPercent, 100);
				}
			}

			// We are required to pass '1' back through the EventParametersBlock for the process to continue.
			*((int32*)EventParameterBlock) = 1;
		}
	}
};

/** Winding modes. */
enum EWindingMode
{
	/** Maintain the winding of the mesh. */
	WINDING_Keep,
	/** Reverse the winding of the mesh. */
	WINDING_Reverse,
	WINDING_MAX
};

//@third party code BEGIN SIMPLYGON 
static void* GSimplygonSDKDLLHandle = nullptr;
//@third party code END SIMPLYGON

class FSimplygonMeshReduction
	: public IMeshReduction
	, public IMeshMerging
	//@third party code BEGIN SIMPLYGON 
	, public IMeshMaterialReduction
	//@third party code END SIMPLYGON
{
public:
	virtual ~FSimplygonMeshReduction()
	{
	}

	virtual const FString& GetVersionString() const override
	{
		return VersionString;
	}

	virtual void Reduce(
		FRawMesh& OutReducedMesh,
		float& OutMaxDeviation,
		const FRawMesh& InMesh,
		const FMeshReductionSettings& InSettings
		) override
	{
		SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromRawMesh(InMesh);
		check(GeometryData);

		//@third party code BEGIN SIMPLYGON
		SimplygonSDK::spScene Scene = SDK->CreateScene();

		SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();
		Mesh->SetGeometry(GeometryData);
		Mesh->SetName(TCHAR_TO_ANSI(*FString::Printf(TEXT("UnrealMesh"))));
		Scene->GetRootNode()->AddChild(Mesh);
		//@third party code END SIMPLYGON

		SimplygonSDK::spReductionProcessor ReductionProcessor = SDK->CreateReductionProcessor();
		ReductionProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
		ReductionProcessor->SetScene(Scene);

		SimplygonSDK::spRepairSettings RepairSettings = ReductionProcessor->GetRepairSettings();
		RepairSettings->SetWeldDist(InSettings.WeldingThreshold);
		RepairSettings->SetTjuncDist(InSettings.WeldingThreshold);

		SimplygonSDK::spReductionSettings ReductionSettings = ReductionProcessor->GetReductionSettings();
		SetReductionSettings(ReductionSettings, InSettings, GeometryData->GetTriangleCount());

		//@third party code BEGIN SIMPLYGON
		//Set visibility settings
		SimplygonSDK::spVisibilitySettings VisibilitySettings = ReductionProcessor->GetVisibilitySettings();
		VisibilitySettings->SetCullOccludedGeometry(InSettings.bCullOccluded);
		int32 TempAggressiveness = InSettings.VisibilityAggressiveness + 1; //+1 because there is an offset in aggressiveness options
		VisibilitySettings->SetVisibilityWeightsPower(TempAggressiveness);
		VisibilitySettings->SetUseVisibilityWeightsInReducer(InSettings.bVisibilityAided);
		//@third party code END SIMPLYGON

		SimplygonSDK::spNormalCalculationSettings NormalSettings = ReductionProcessor->GetNormalCalculationSettings();
		SetNormalSettings(NormalSettings, InSettings);

		ReductionProcessor->RunProcessing();

		SimplygonSDK::spSceneMesh ReducedMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>(Scene->GetRootNode()->GetChild(0));
		CreateRawMeshFromGeometry(OutReducedMesh, ReducedMesh->GetGeometry(), WINDING_Keep);
		OutMaxDeviation = ReductionProcessor->GetResultDeviation();
	}

	//@third party code BEGIN SIMPLYGON 
	virtual void ReduceWithMaterialLOD(
	struct FRawMesh& OutReducedMesh,
		float& OutMaxDeviation,
		const FMeshMaterialReductionData& InData,
		const struct FMeshReductionSettings& InSettings,
		TIndirectArray<FFlattenMaterial>& OutMaterials
		) override
	{
		SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromRawMesh(*InData.Mesh, InData.TexcoordBounds, InData.NewUVs);
		check(GeometryData);

		SimplygonSDK::spScene Scene = SDK->CreateScene();

		SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();
		Mesh->SetGeometry(GeometryData);
		Mesh->SetName(TCHAR_TO_ANSI(*FString::Printf(TEXT("UnrealMesh"))));
		Scene->GetRootNode()->AddChild(Mesh);

		//@third party code BEGIN SIMPLYGON
		{
			/*SimplygonSDK::spWavefrontExporter objexp2 = SDK->CreateWavefrontExporter();
			objexp2->SetExportFilePath( "d:/BeforeMeshLODReduction.obj" );
			objexp2->SetSingleGeometry( GeometryData);
			objexp2->RunExport();*/
		}
		//@third party code END SIMPLYGON

		SimplygonSDK::spReductionProcessor ReductionProcessor = SDK->CreateReductionProcessor();
		ReductionProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
		ReductionProcessor->SetScene(Scene);

		SimplygonSDK::spRepairSettings RepairSettings = ReductionProcessor->GetRepairSettings();
		RepairSettings->SetWeldDist(InSettings.WeldingThreshold);
		RepairSettings->SetTjuncDist(InSettings.WeldingThreshold);

		SimplygonSDK::spReductionSettings ReductionSettings = ReductionProcessor->GetReductionSettings();
		SetReductionSettings(ReductionSettings, InSettings, GeometryData->GetTriangleCount());

		//Set visibility settings
		SimplygonSDK::spVisibilitySettings VisibilitySettings = ReductionProcessor->GetVisibilitySettings();
		VisibilitySettings->SetCullOccludedGeometry(InSettings.bCullOccluded);
		int32 TempAggressiveness = InSettings.VisibilityAggressiveness + 1; //+1 because there is an offset in aggressiveness options
		VisibilitySettings->SetVisibilityWeightsPower(TempAggressiveness);
		VisibilitySettings->SetUseVisibilityWeightsInReducer(InSettings.bVisibilityAided);

		SimplygonSDK::spNormalCalculationSettings NormalSettings = ReductionProcessor->GetNormalCalculationSettings();
		SetNormalSettings(NormalSettings, InSettings);

		// Process data
		SimplygonProcessLOD(ReductionProcessor, InData, InSettings.MaterialLODSettings, false, OutMaterials);

		SimplygonSDK::spSceneMesh ReducedMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>(Scene->GetRootNode()->GetChild(0));
		CreateRawMeshFromGeometry(OutReducedMesh, ReducedMesh->GetGeometry(), WINDING_Keep);
		OutMaxDeviation = ReductionProcessor->GetResultDeviation();
	}
	//@third party code END SIMPLYGON

	bool ReduceLODModel(
		FStaticLODModel * SrcModel,
		FStaticLODModel *& OutModel,
		FBoxSphereBounds & Bounds,
		float &MaxDeviation,
		const FReferenceSkeleton& RefSkeleton,
		const FSkeletalMeshOptimizationSettings& Settings
		)
	{
		const bool bUsingMaxDeviation = (Settings.ReductionMethod == SMOT_MaxDeviation && Settings.MaxDeviationPercentage > 0.0f);
		const bool bUsingReductionRatio = (Settings.ReductionMethod == SMOT_NumOfTriangles && Settings.NumOfTrianglesPercentage < 1.0f);
		const bool bProcessGeometry = (bUsingMaxDeviation || bUsingReductionRatio);
		const bool bProcessBones = (Settings.BoneReductionRatio < 1.0f || Settings.MaxBonesPerVertex < MAX_TOTAL_INFLUENCES);
		const bool bOptimizeMesh = (bProcessGeometry || bProcessBones);

		// We'll need to store the max deviation after optimization if we wish to recalculate the LOD's display distance
		MaxDeviation = 0.0f;

		if (bOptimizeMesh)
		{
			//Create a simplygon scene. The scene by default contains a bone table that is required for bone reduction.
			SimplygonSDK::spScene Scene = SDK->CreateScene();
			check(Scene);

			// Create bone hierarchy for simplygon.
			TArray<SimplygonSDK::rid> BoneTableIDs;
			CreateSkeletalHierarchy(Scene, RefSkeleton, BoneTableIDs);

			// Create a new scene mesh object
			SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromSkeletalLODModel(Scene, *SrcModel, BoneTableIDs);
			FDefaultEventHandler SimplygonEventHandler;
			SimplygonSDK::spReductionProcessor ReductionProcessor = SDK->CreateReductionProcessor();
			ReductionProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
			ReductionProcessor->SetScene(Scene);

			SimplygonSDK::spRepairSettings RepairSettings = ReductionProcessor->GetRepairSettings();
			RepairSettings->SetWeldDist(Settings.WeldingThreshold);
			RepairSettings->SetTjuncDist(Settings.WeldingThreshold);

			SimplygonSDK::spReductionSettings ReductionSettings = ReductionProcessor->GetReductionSettings();
			SetReductionSettings(Settings, Bounds.SphereRadius, GeometryData->GetTriangleCount(), ReductionSettings);

			SimplygonSDK::spNormalCalculationSettings NormalSettings = ReductionProcessor->GetNormalCalculationSettings();
			SetNormalSettings(Settings, NormalSettings);

			if (bProcessBones)
			{
				SimplygonSDK::spBoneSettings BoneSettings = ReductionProcessor->GetBoneSettings();
				SetBoneSettings(Settings, BoneSettings);
			}

			ReductionProcessor->RunProcessing();

			// We require the max deviation if we're calculating the LOD's display distance.
			MaxDeviation = ReductionProcessor->GetResultDeviation();

			CreateSkeletalLODModelFromGeometry(GeometryData, RefSkeleton, OutModel);
		}

		return bOptimizeMesh;
	}

	//@third party code BEGIN SIMPLYGON
	bool ReduceLODModelWithMaterialLOD(
		FMeshMaterialReductionData& Data,
		USkeletalMesh* SkeletalMesh,
		FStaticLODModel *& OutModel,
		int32 BaseLODModel,
		int32 LODIndex,
		float &MaxDeviation,
		const FSkeletalMeshOptimizationSettings& Settings,
		TIndirectArray<FFlattenMaterial>& OutMaterials
		)
	{
		const bool bUsingMaxDeviation = (Settings.MaxDeviationPercentage > 0.0f);
		const bool bUsingReductionRatio = (Settings.NumOfTrianglesPercentage < 1.0f);
		const bool bProcessGeometry = (bUsingMaxDeviation || bUsingReductionRatio);
		const bool bProcessBones = (Settings.BoneReductionRatio < 1.0f && Settings.MaxBonesPerVertex < MAX_TOTAL_INFLUENCES);
		const bool bOptimizeMesh = (bProcessGeometry || bProcessBones);

		// We'll need to store the max deviation after optimization if we wish to recalculate the LOD's display distance
		MaxDeviation = 0.0f;

		if (bOptimizeMesh)
		{
			//Create a simplygon scene. The scene by default contains a bone table that is required for bone reduction.
			SimplygonSDK::spScene Scene = SDK->CreateScene();
			check(Scene);

			// Create bone hierarchy for simplygon.
			TArray<SimplygonSDK::rid> BoneTableIDs;
			CreateSkeletalHierarchy(Scene, SkeletalMesh->RefSkeleton, BoneTableIDs);

			// Create a new scene mesh object
			SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromSkeletalLODModel(Scene, *Data.LODModel, BoneTableIDs, Data.TexcoordBounds, Data.NewUVs);
			FDefaultEventHandler SimplygonEventHandler;
			SimplygonSDK::spReductionProcessor ReductionProcessor = SDK->CreateReductionProcessor();
			ReductionProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
			ReductionProcessor->SetScene(Scene);

			AddMorphTargetsToGeometry(SkeletalMesh, BaseLODModel, GeometryData);

			SimplygonSDK::spRepairSettings RepairSettings = ReductionProcessor->GetRepairSettings();
			RepairSettings->SetWeldDist(Settings.WeldingThreshold);
			RepairSettings->SetTjuncDist(Settings.WeldingThreshold);

			SimplygonSDK::spReductionSettings ReductionSettings = ReductionProcessor->GetReductionSettings();
			SetReductionSettings(Settings, SkeletalMesh->Bounds.SphereRadius, GeometryData->GetTriangleCount(), ReductionSettings);

			SimplygonSDK::spNormalCalculationSettings NormalSettings = ReductionProcessor->GetNormalCalculationSettings();
			SetNormalSettings(Settings, NormalSettings);

			if (bProcessBones)
			{
				SimplygonSDK::spBoneSettings BoneSettings = ReductionProcessor->GetBoneSettings();
				SetBoneSettings(Settings, BoneSettings);
			}

			// Process data
			SimplygonProcessLOD(ReductionProcessor, Data, Settings.MaterialLODSettings, true, OutMaterials);

			// We require the max deviation if we're calculating the LOD's display distance.
			MaxDeviation = ReductionProcessor->GetResultDeviation();

			TArray<int32> SourceWedgeMap;
			CreateSkeletalLODModelFromGeometry(GeometryData, SkeletalMesh->RefSkeleton, OutModel, &SourceWedgeMap);

			uint32 LODModelVertexCount = OutModel->NumVertices;
			GetMorphTargetsFromGeometry(SkeletalMesh, LODIndex, LODModelVertexCount, GeometryData, SourceWedgeMap);
		}

		return bOptimizeMesh;
	}

	bool RemeshLODModelWithMaterialLOD(
		FMeshMaterialReductionData& Data,
		FStaticLODModel *& OutModel,
		FBoxSphereBounds & Bounds,
		const FReferenceSkeleton& RefSkeleton,
		const FSimplygonRemeshingSettings& Settings,
		FFlattenMaterial& OutMaterial
		)
	{
		//		const bool bProcessBones = (Settings.BoneReductionRatio < 1.0f || Settings.MaxBonesPerVertex < MAX_TOTAL_INFLUENCES);

		//Create a simplygon scene. The scene by default contains a bone table that is required for bone reduction.
		SimplygonSDK::spScene Scene = SDK->CreateScene();
		check(Scene);

		// Create bone hierarchy for simplygon.
		TArray<SimplygonSDK::rid> BoneTableIDs;
		CreateSkeletalHierarchy(Scene, RefSkeleton, BoneTableIDs);

		// Create a new scene mesh object
		SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromSkeletalLODModel(Scene, *Data.LODModel, BoneTableIDs, Data.TexcoordBounds, Data.NewUVs);
		FDefaultEventHandler SimplygonEventHandler;
		SimplygonSDK::spRemeshingProcessor RemeshingProcessor = SDK->CreateRemeshingProcessor();
		RemeshingProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);

		SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();
		Mesh->SetGeometry(GeometryData);
		Mesh->SetName("Mesh");
		Scene->GetRootNode()->AddChild(Mesh);

		RemeshingProcessor->SetScene(Scene);

		SetRemeshingSettings(Settings, RemeshingProcessor);

		//todo: use this, remeshing has bone settings
		//		if(bProcessBones)
		//		{
		//			SimplygonSDK::spBoneSettings BoneSettings = RemeshingProcessor->GetBoneSettings();
		//			SetBoneSettings( Settings, BoneSettings );
		//		}

		// Process data
		TArray<FMeshMaterialReductionData*> DataArray;
		DataArray.Add(&Data);
		SimplygonProcessMassiveLOD(RemeshingProcessor, DataArray, Settings.MaterialLODSettings, OutMaterial);

		SimplygonSDK::spSceneMesh NewMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>(Scene->GetRootNode()->GetChild(1));
		SimplygonSDK::spGeometryData NewGeom = NewMesh->GetGeometry();
		CreateSkeletalLODModelFromGeometry(NewGeom, RefSkeleton, OutModel);

		return true;
	}
	//@third party code END SIMPLYGON

	virtual bool ReduceSkeletalMesh(
		USkeletalMesh* SkeletalMesh,
		int32 LODIndex,
		const FSkeletalMeshOptimizationSettings& Settings,
		//@third party code BEGIN SIMPLYGON
		const struct FSimplygonRemeshingSettings& RemeshingSettings,
		//@third party code END SIMPLYGON
		bool bCalcLODDistance
		) override
	{
		check(SkeletalMesh);
		check(LODIndex >= 0);
		check(LODIndex <= SkeletalMesh->LODInfo.Num());

		FSkeletalMeshResource* SkeletalMeshResource = SkeletalMesh->GetImportedResource();
		check(SkeletalMeshResource);
		check(LODIndex <= SkeletalMeshResource->LODModels.Num());

		//@third party code BEGIN SIMPLYGON
		//FStaticLODModel* SrcModel = &SkeletalMesh->PreModifyMesh();
		bool bDoingReduction = !RemeshingSettings.bActive;
		int32 BaseLODModel = Settings.BaseLODModel;
		int32 LastIndexOfLODChain = Settings.LODChainLastIndex;
		FStaticLODModel* SrcModel = bDoingReduction ? &SkeletalMeshResource->LODModels[BaseLODModel] : &SkeletalMeshResource->LODModels[0];
		LODIndex = LODIndex + LastIndexOfLODChain;
		//@third party code END SIMPLYGON

		TComponentReregisterContext<USkinnedMeshComponent> ReregisterContext;
		SkeletalMesh->ReleaseResources();
		SkeletalMesh->ReleaseResourcesFence.Wait();

		// Insert a new LOD model entry if needed.
		if (LODIndex == SkeletalMeshResource->LODModels.Num())
		{
			SkeletalMeshResource->LODModels.Add(0);
		}

		// We'll need to store the max deviation after optimization if we wish to recalculate the LOD's display distance
		float MaxDeviation = 0.0f;

		// Swap in a new model, delete the old.
		check(LODIndex < SkeletalMeshResource->LODModels.Num());
		FStaticLODModel** LODModels = SkeletalMeshResource->LODModels.GetData();
		//@third party code BEGIN SIMPLYGON
		//delete LODModels[LODIndex]; -- keep model valid until we'll be ready to replace it; required to be able to refresh UI with mesh stats
		//@third party code END SIMPLYGON

		// Copy over LOD info from LOD0 if there is no previous info.
		if (LODIndex == SkeletalMesh->LODInfo.Num())
		{
			FSkeletalMeshLODInfo* NewLODInfo = new(SkeletalMesh->LODInfo) FSkeletalMeshLODInfo;
			FSkeletalMeshLODInfo& OldLODInfo = SkeletalMesh->LODInfo[0];
			*NewLODInfo = OldLODInfo;

			//@third party code BEGIN SIMPLYGON
			/*// creates LOD Material map for a newly generated LOD model
			int32 NumSections = LODModels[0]->NumNonClothingSections();
			if (NewLODInfo->LODMaterialMap.Num() != NumSections)
			{
			NewLODInfo->LODMaterialMap.Empty(NumSections);
			NewLODInfo->LODMaterialMap.AddUninitialized(NumSections);
			}

			for (int32 Index = 0; Index < NumSections; Index++)
			{
			NewLODInfo->LODMaterialMap[Index] = Index;
			} */
			//@third party code END SIMPLYGON
		}

		// now try bone reduction process if it's setup
		TMap<FBoneIndexType, FBoneIndexType> BonesToRemove;

		IMeshBoneReductionModule& MeshBoneReductionModule = FModuleManager::Get().LoadModuleChecked<IMeshBoneReductionModule>("MeshBoneReduction");
		IMeshBoneReduction * MeshBoneReductionInterface = MeshBoneReductionModule.GetMeshBoneReductionInterface();

		// See if we'd like to remove extra bones first
		if (MeshBoneReductionInterface->GetBoneReductionData(SkeletalMesh, LODIndex, BonesToRemove))
		{
			// if we do, now create new model and make a copy of SrcMesh to cut the bone count
			FStaticLODModel * NewSrcModel = new FStaticLODModel();

			//	Bulk data arrays need to be locked before a copy can be made.
			SrcModel->RawPointIndices.Lock(LOCK_READ_ONLY);
			SrcModel->LegacyRawPointIndices.Lock(LOCK_READ_ONLY);
			*NewSrcModel = *SrcModel;
			SrcModel->RawPointIndices.Unlock();
			SrcModel->LegacyRawPointIndices.Unlock();

			// The index buffer needs to be rebuilt on copy.
			FMultiSizeIndexContainerData IndexBufferData;
			SrcModel->MultiSizeIndexContainer.GetIndexBufferData(IndexBufferData);
			NewSrcModel->MultiSizeIndexContainer.RebuildIndexBuffer(IndexBufferData);

			// now fix up SrcModel to NewSrcModel
			SrcModel = NewSrcModel;
			//todo: check - memory leak here - SrcModel is not released?

			// fix up chunks to remove the bones that set to be removed
			for (int32 ChunkIndex = 0; ChunkIndex< NewSrcModel->Chunks.Num(); ++ChunkIndex)
			{
				MeshBoneReductionInterface->FixUpChunkBoneMaps(NewSrcModel->Chunks[ChunkIndex], BonesToRemove);
			}
		}

		FStaticLODModel * NewModel = new FStaticLODModel();
		//@third party code BEGIN SIMPLYGON
		//LODModels[LODIndex] = NewModel; - don't replace model until NewModel will be valid

		IMeshUtilities& MeshUtilities = FModuleManager::Get().LoadModuleChecked<IMeshUtilities>("MeshUtilities");
		ISimplygonUtilities* SimplygonUtilities = MeshUtilities.GetSimplygonUtilitiesInterface();
		check(SimplygonUtilities);
		const FSimplygonMaterialLODSettings& MaterialSettings = Settings.MaterialLODSettings;

		FMeshMaterialReductionData* Data = SimplygonUtilities->CreateMeshReductionData(SrcModel);

		bool bMakeMaterialLOD = MaterialSettings.bActive && (SimplygonUtilities != nullptr);

		if (bMakeMaterialLOD)
		{
			// Gather material data
			const FSkeletalMeshLODInfo& LODInfo = SkeletalMesh->LODInfo[BaseLODModel];
			for (int32 SectionIndex = 0; SectionIndex < SrcModel->Sections.Num(); SectionIndex++)
			{
				int32 LODMaterialIndex = SrcModel->Sections[SectionIndex].MaterialIndex;
				int32 MaterialIndex = LODMaterialIndex;
				if (LODInfo.LODMaterialMap.IsValidIndex(LODMaterialIndex))
				{
					MaterialIndex = LODInfo.LODMaterialMap[LODMaterialIndex];
				}

				UMaterialInterface* MaterialToAdd = SkeletalMesh->Materials[MaterialIndex].MaterialInterface;
				// Add material to NonFlattenMaterials list at LODMaterialIndex position, as it will be used
				// by CreateGeometryFromSkeletalLODModel(). In most cases LODMaterialIndex will equals to
				// SectionIndex, but for case when number of materials is smaller than number of sections
				// mapping will be different.
				if (Data->NonFlattenMaterials.Num() <= LODMaterialIndex)
				{
					Data->NonFlattenMaterials.AddZeroed(LODMaterialIndex - Data->NonFlattenMaterials.Num() + 1);
				}
				Data->NonFlattenMaterials[LODMaterialIndex] = MaterialToAdd;
			}

			Data->BuildOutputMaterialMap(MaterialSettings, bDoingReduction);

			uint32 TextureWidth = MaterialSettings.GetTextureResolutionFromEnum(MaterialSettings.TextureWidth);
			uint32 TextureHeight = MaterialSettings.GetTextureResolutionFromEnum(MaterialSettings.TextureHeight);
			SimplygonUtilities->GetTextureCoordinateBoundsForSkeletalMesh(*SrcModel, Data->TexcoordBounds);
			if (!MaterialSettings.bReuseExistingCharts || !bDoingReduction)
			{
				GenerateUniqueUVs(*SrcModel, SkeletalMesh->RefSkeleton, 0.8f, TextureWidth, TextureHeight, 3.0f, Data->NewUVs);
			}

			Data->BuildFlattenMaterials(MaterialSettings, TextureWidth, TextureHeight);
		}

		TIndirectArray<FFlattenMaterial> OutFlattenMaterials;

		// Reduce LOD model with SrcMesh
		bool bReduced = false;
		if (bDoingReduction)
		{
			// Original code calls ReduceLODModel(), we're calling our customized function here
			bReduced = ReduceLODModelWithMaterialLOD(
				*Data,
				SkeletalMesh,
				NewModel,
				BaseLODModel,
				LODIndex,
				MaxDeviation,
				Settings,
				OutFlattenMaterials);
		}
		else
		{
			// Create single FFlattenMaterial instance and add it to OutMaterials array. This is needed to unify
			// code below - we'll iterate over OutFlattenMaterials array to build output materials.
			FFlattenMaterial* OutFlattenMaterial = new (OutFlattenMaterials) FFlattenMaterial;

			bReduced = RemeshLODModelWithMaterialLOD(
				*Data,
				NewModel,
				SkeletalMesh->Bounds,
				SkeletalMesh->RefSkeleton,
				RemeshingSettings,
				*OutFlattenMaterial);

			MaxDeviation = ISimplygonUtilities::ConvertScreenSizeToDeviation(SkeletalMesh->Bounds.SphereRadius, (float)RemeshingSettings.ScreenSize);
		}

		// Now replace model
		if (bReduced)
		{
			delete LODModels[LODIndex];
			LODModels[LODIndex] = NewModel;
		}

		// Need to remove the old baked material if it exists
		FString BakedMaterialExt = FString::Printf(TEXT("_SgBakedMaterial_LOD%d"), LODIndex); //Should be a global in SimplygonUtilities
		for (int32 MaterialIndex = 0; MaterialIndex < SkeletalMesh->Materials.Num(); ++MaterialIndex)
		{
			UMaterialInterface* Material = SkeletalMesh->Materials[MaterialIndex].MaterialInterface;
			if (!Material || !Material->GetName().Contains(BakedMaterialExt))
			{
				continue;
			}

			SkeletalMesh->Materials.RemoveAt(MaterialIndex);
			// fixup LOD material indices for all LODs
			for (int32 CheckLODIndex = 1; CheckLODIndex < SkeletalMesh->LODInfo.Num(); CheckLODIndex++)
			{
				FSkeletalMeshLODInfo& CheckLODInfo = SkeletalMesh->LODInfo[CheckLODIndex];
				for (int32 CheckMaterialIndex = 0; CheckMaterialIndex < CheckLODInfo.LODMaterialMap.Num(); CheckMaterialIndex++)
				{
					if (CheckLODInfo.LODMaterialMap[CheckMaterialIndex] > MaterialIndex)
					{
						CheckLODInfo.LODMaterialMap[CheckMaterialIndex]--;
					}
				}
			}
		}

		if (bMakeMaterialLOD && bReduced)
		{
			// Prepare place for baked materials
			FSkeletalMeshLODInfo& NewLODInfo = SkeletalMesh->LODInfo[LODIndex];
			NewLODInfo.LODMaterialMap.SetNumZeroed(OutFlattenMaterials.Num());

			for (int32 OutMaterialIndex = 0; OutMaterialIndex < OutFlattenMaterials.Num(); OutMaterialIndex++)
			{
				const FFlattenMaterial& OutFlattenMaterial = OutFlattenMaterials[OutMaterialIndex];
				FString AbsoluteBakedMaterialName = FPackageName::GetLongPackagePath(SkeletalMesh->GetOutermost()->GetName());
				AbsoluteBakedMaterialName += TEXT("/SimplygonMaterials/") + SkeletalMesh->GetName() + BakedMaterialExt;
				if (OutFlattenMaterials.Num() > 1)
				{
					// Append material index to name
					AbsoluteBakedMaterialName += FString::Printf(TEXT("_%d"), OutMaterialIndex);
				}

				//Create baked material
				UMaterialInterface* BakedMaterial = FMaterialUtilities::SgCreateMaterial(OutFlattenMaterial, NULL, AbsoluteBakedMaterialName, RF_Public | RF_Standalone);

				//Save the package silently
				SimplygonUtilities->SaveMaterial(BakedMaterial);

				// flag the property (Materials) we're modifying so that not all of the object is rebuilt.
				UProperty* ChangedProperty = NULL;
				ChangedProperty = FindField<UProperty>(USkeletalMesh::StaticClass(), "Materials");
				check(ChangedProperty);
				SkeletalMesh->PreEditChange(ChangedProperty);

				// store baked material to Materials and LODInfo	
				int32 NewMaterialIndex = SkeletalMesh->Materials.Add(FSkeletalMaterial(BakedMaterial));
				NewLODInfo.LODMaterialMap[OutMaterialIndex] = NewMaterialIndex;
			}
		}
		else
		{
			// creates LOD Material map for a newly generated LOD model
			FSkeletalMeshLODInfo& NewLODInfo = SkeletalMesh->LODInfo[LODIndex];
			int32 NumSections = NewModel->NumNonClothingSections();
			NewLODInfo.LODMaterialMap.SetNumZeroed(NumSections);

			const FSkeletalMeshLODInfo& SrcLODInfo = SkeletalMesh->LODInfo[BaseLODModel];
			for (int32 Index = 0; Index < NumSections; Index++)
			{
				// Remap new material index through base LODMaterialMap
				int32 LODMaterialIndex = NewModel->Sections[Index].MaterialIndex;
				if (SrcLODInfo.LODMaterialMap.IsValidIndex(LODMaterialIndex))
				{
					LODMaterialIndex = SrcLODInfo.LODMaterialMap[LODMaterialIndex];
				}
				NewLODInfo.LODMaterialMap[Index] = LODMaterialIndex;
			}
		}

		if (bReduced)
			//@third party code END SIMPLYGON
		{
			if (bCalcLODDistance)
			{
				if (LODIndex == 0)
				{
					SkeletalMesh->LODInfo[LODIndex].ScreenSize = 1.0f;
				}
				else if (MaxDeviation <= 0.0f)
				{
					SkeletalMesh->LODInfo[LODIndex].ScreenSize = 1.0f / (SkeletalMesh->LODInfo.Num() * LODIndex);
				}
				else
				{
					float ViewDistance = CalculateViewDistance(MaxDeviation);
					SkeletalMesh->LODInfo[LODIndex].ScreenSize = 2.0f * SkeletalMesh->Bounds.SphereRadius / ViewDistance;
				}
			}

			// Flag this LOD as having been simplified.
			SkeletalMesh->LODInfo[LODIndex].bHasBeenSimplified = true;
			SkeletalMesh->bHasBeenSimplified = true;
		}
		else
		{
			//	Bulk data arrays need to be locked before a copy can be made.
			SrcModel->RawPointIndices.Lock(LOCK_READ_ONLY);
			SrcModel->LegacyRawPointIndices.Lock(LOCK_READ_ONLY);
			*NewModel = *SrcModel;
			SrcModel->RawPointIndices.Unlock();
			SrcModel->LegacyRawPointIndices.Unlock();

			// The index buffer needs to be rebuilt on copy.
			FMultiSizeIndexContainerData IndexBufferData;
			SrcModel->MultiSizeIndexContainer.GetIndexBufferData(IndexBufferData);
			NewModel->MultiSizeIndexContainer.RebuildIndexBuffer(IndexBufferData);

			// Required bones are recalculated later on.
			NewModel->RequiredBones.Empty();
			SkeletalMesh->LODInfo[LODIndex].bHasBeenSimplified = false;
		}

		SkeletalMesh->CalculateRequiredBones(SkeletalMeshResource->LODModels[LODIndex], SkeletalMesh->RefSkeleton, &BonesToRemove);
		SkeletalMesh->PostEditChange();
		SkeletalMesh->InitResources();

		if (LODIndex >= SkeletalMesh->OptimizationSettings.Num())
		{
			FSkeletalMeshOptimizationSettings DefaultSettings;
			const FSkeletalMeshOptimizationSettings SettingsToCopy =
				SkeletalMesh->OptimizationSettings.Num() ? SkeletalMesh->OptimizationSettings.Last() : DefaultSettings;
			while (LODIndex >= SkeletalMesh->OptimizationSettings.Num())
			{
				SkeletalMesh->OptimizationSettings.Add(SettingsToCopy);
			}
		}
		check(LODIndex < SkeletalMesh->OptimizationSettings.Num());
		SkeletalMesh->OptimizationSettings[LODIndex] = Settings;

		//@third party code BEGIN SIMPLYGON
		// Cleanup
		delete Data;
		//@third party code END SIMPLYGON

		return true;
	}

	virtual bool IsSupported() const override
	{
		return true;
	}

	//@third party code BEGIN SIMPLYGON 
	static void Destroy()
	{
		if (GSimplygonSDKDLLHandle != nullptr)
		{
			typedef int(*DeinitializeSimplygonSDKPtr)();
			DeinitializeSimplygonSDKPtr DeinitializeSimplygonSDK = (DeinitializeSimplygonSDKPtr)FPlatformProcess::GetDllExport(GSimplygonSDKDLLHandle, TEXT("DeinitializeSimplygonSDK"));
			DeinitializeSimplygonSDK();
			FPlatformProcess::FreeDllHandle(GSimplygonSDKDLLHandle);
			GSimplygonSDKDLLHandle = nullptr;
		}
	}
	//@third party code END SIMPLYGON

	static FSimplygonMeshReduction* Create()
	{
		//@third party code BEGIN SIMPLYGON
		if (FParse::Param(FCommandLine::Get(), TEXT("NoSimplygon")))
		{
			//The user specified that simplygon should not be used
			UE_LOG(LogSimplygon, Warning, TEXT("Simplygon is disabled with -NoSimplygon flag"));
			return  NULL;
		}
		const ANSICHAR* SIMPLYGON_VERSION_STRING = "7.0";
		//@third party code END SIMPLYGON

		FString DllPath(FPaths::Combine(*FPaths::EngineDir(), TEXT("Binaries/ThirdParty/Simplygon")));
		FString DllFilename(FPaths::Combine(*DllPath, TEXT("SimplygonSDKEpicUE4Releasex64.dll")));
		if (!FPaths::FileExists(DllFilename))
		{
			DllFilename = FPaths::Combine(*DllPath, TEXT("SimplygonSDKRuntimeReleasex64.dll"));
		}

		// If the DLL just doesn't exist, fail gracefully. Licensees and Rocket users will not necessarily have Simplygon.
		if (!FPaths::FileExists(DllFilename))
		{
			UE_LOG(LogSimplygon, Warning, TEXT("Simplygon DLL not present - disabling."));
			return NULL;
		}

		//@third party code BEGIN SIMPLYGON 
		// Otherwise fail
		GSimplygonSDKDLLHandle = FPlatformProcess::GetDllHandle(*DllFilename);
		if (GSimplygonSDKDLLHandle == NULL)
		{
			int32 ErrorNum = FPlatformMisc::GetLastError();
			TCHAR ErrorMsg[1024];
			FPlatformMisc::GetSystemErrorMessage(ErrorMsg, 1024, ErrorNum);
			UE_LOG(LogSimplygon, Error, TEXT("Failed to get Simplygon DLL handle: %s (%d)"), ErrorMsg, ErrorNum);
			return NULL;
		}
		//@third party code END SIMPLYGON

		// Get API function pointers of interest
		typedef void(*GetInterfaceVersionSimplygonSDKPtr)(ANSICHAR*);
		GetInterfaceVersionSimplygonSDKPtr GetInterfaceVersionSimplygonSDK = (GetInterfaceVersionSimplygonSDKPtr)FPlatformProcess::GetDllExport(GSimplygonSDKDLLHandle, TEXT("GetInterfaceVersionSimplygonSDK"));

		typedef int(*InitializeSimplygonSDKPtr)(const char* LicenseData, SimplygonSDK::ISimplygonSDK** OutInterfacePtr);
		InitializeSimplygonSDKPtr InitializeSimplygonSDK = (InitializeSimplygonSDKPtr)FPlatformProcess::GetDllExport(GSimplygonSDKDLLHandle, TEXT("InitializeSimplygonSDK"));

		if ((GetInterfaceVersionSimplygonSDK == NULL) || (InitializeSimplygonSDK == NULL))
		{
			// Couldn't find the functions we need.  
			UE_LOG(LogSimplygon, Warning, TEXT("Failed to acquire Simplygon DLL exports."));
			FPlatformProcess::FreeDllHandle(GSimplygonSDKDLLHandle);
			GSimplygonSDKDLLHandle = NULL;
			return NULL;
		}

		//@third party code BEGIN SIMPLYGON 
		if (FCStringAnsi::Strncmp(SimplygonSDK::GetHeaderVersion(), SIMPLYGON_VERSION_STRING, FCStringAnsi::Strlen(SIMPLYGON_VERSION_STRING)) != 0)
		{
			UE_LOG(LogSimplygon, Error, TEXT("Simplygon version doesn't match the version expected by the Simplygon UE4 integration"));
			UE_LOG(LogSimplygon, Error, TEXT("Expected version %s, found version %s"), ANSI_TO_TCHAR(SIMPLYGON_VERSION_STRING), ANSI_TO_TCHAR(SimplygonSDK::GetHeaderVersion()));
			FPlatformProcess::FreeDllHandle(GSimplygonSDKDLLHandle);
			GSimplygonSDKDLLHandle = NULL;
			return NULL;
		}
		//@third party code END SIMPLYGON

		ANSICHAR VersionHash[200];
		GetInterfaceVersionSimplygonSDK(VersionHash);
		if (FCStringAnsi::Strcmp(VersionHash, SimplygonSDK::GetInterfaceVersionHash()) != 0)
		{
			UE_LOG(LogSimplygon, Warning, TEXT("Library version mismatch. Header=%s Lib=%s"), ANSI_TO_TCHAR(SimplygonSDK::GetInterfaceVersionHash()), ANSI_TO_TCHAR(VersionHash));
			FPlatformProcess::FreeDllHandle(GSimplygonSDKDLLHandle);
			GSimplygonSDKDLLHandle = NULL;
			return NULL;
		}

		const char* LicenseData = NULL;
		TArray<uint8> LicenseFileContents;
		if (FFileHelper::LoadFileToArray(LicenseFileContents, *FPaths::Combine(*DllPath, TEXT("Simplygon_5_license.dat")), FILEREAD_Silent) && LicenseFileContents.Num() > 0)
		{
			LicenseData = (const char*)LicenseFileContents.GetData();
		}

		SimplygonSDK::ISimplygonSDK* SDK = NULL;
		int32 Result = InitializeSimplygonSDK(LicenseData, &SDK);
		if (Result != SimplygonSDK::SG_ERROR_NOERROR && Result != SimplygonSDK::SG_ERROR_ALREADYINITIALIZED)
		{
			UE_LOG(LogSimplygon, Warning, TEXT("Failed to initialize Simplygon. Error: %d."), Result);
			FPlatformProcess::FreeDllHandle(GSimplygonSDKDLLHandle);
			GSimplygonSDKDLLHandle = NULL;
			return NULL;
		}

		return new FSimplygonMeshReduction(SDK);
	}

	struct FMaterialCastingProperties
	{
		bool bCastMaterials;
		bool bCastNormals;
		bool bCastMetallic;
		bool bCastRoughness;
		bool bCastSpecular;

		FMaterialCastingProperties()
			: bCastMaterials(false)
			, bCastNormals(false)
			, bCastMetallic(false)
			, bCastRoughness(false)
			, bCastSpecular(false)
		{
		}
	};

	//@third party code BEGIN SIMPLYGON
	virtual void ProxyLOD(
		const TArray<FMeshMaterialReductionData*>& InData,
		const struct FSimplygonRemeshingSettings& InProxySettings,
		FRawMesh& OutProxyMesh,
		FFlattenMaterial& OutMaterial)
	{
		if (!InData.Num())
		{
			UE_LOG(LogSimplygon, Log, TEXT("The selected meshes are not valid. Make sure to select static meshes only."));
			OutProxyMesh.Empty();
			return;
		}

		//Create a Simplygon Scene
		SimplygonSDK::spScene Scene = SDK->CreateScene();
		SimplygonSDK::spGeometryValidator GeometryValidator = SDK->CreateGeometryValidator();

		//For each raw mesh in array create a scene mesh and populate with geometry data
		for (int32 MeshIndex = 0; MeshIndex < InData.Num(); ++MeshIndex)
		{
			SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromRawMesh(*InData[MeshIndex]->Mesh, InData[MeshIndex]->TexcoordBounds, InData[MeshIndex]->NewUVs);
			if (!GeometryData)
			{
				UE_LOG(LogSimplygon, Warning, TEXT("Geometry data is NULL"));
				continue;
			}

			GeometryData->CleanupNanValues();

			//Validate the geometry
			ValidateGeometry(GeometryValidator, GeometryData);

			check(GeometryData)

#ifdef DEBUG_PROXY_MESH
				SimplygonSDK::spWavefrontExporter objexp = SDK->CreateWavefrontExporter();
			objexp->SetExportFilePath("d:/BeforeProxyMesh.obj");
			objexp->SetSingleGeometry(GeometryData);
			objexp->RunExport();
#endif

			SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();
			Mesh->SetGeometry(GeometryData);
			Mesh->SetName(TCHAR_TO_ANSI(*FString::Printf(TEXT("UnrealMesh%d"), MeshIndex)));
			Scene->GetRootNode()->AddChild(Mesh);

		}

		//Create a remesher
		SimplygonSDK::spRemeshingProcessor RemeshingProcessor = SDK->CreateRemeshingProcessor();

		//Setup the remesher
		RemeshingProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
		SetRemeshingSettings(InProxySettings, RemeshingProcessor);
		RemeshingProcessor->SetScene(Scene);

		// Process data
		SimplygonProcessMassiveLOD(RemeshingProcessor, InData, InProxySettings.MaterialLODSettings, OutMaterial);

		//Collect the proxy mesh
		SimplygonSDK::spSceneMesh ProxyMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>(Scene->GetRootNode()->GetChild(0));

#ifdef DEBUG_PROXY_MESH
		SimplygonSDK::spWavefrontExporter objexp = SDK->CreateWavefrontExporter();
		objexp->SetExportFilePath("d:/AfterProxyMesh.obj");
		objexp->SetSingleGeometry(ProxyMesh->GetGeometry());
		objexp->RunExport();
#endif
		//Convert geometry data to raw mesh data
		SimplygonSDK::spGeometryData outGeom = ProxyMesh->GetGeometry();
		CreateRawMeshFromGeometry(OutProxyMesh, ProxyMesh->GetGeometry(), WINDING_Keep);

		// Default smoothing
		OutProxyMesh.FaceSmoothingMasks.Init(1, OutProxyMesh.FaceMaterialIndices.Num());
	}

	virtual void AggregateLOD(
		const TArray<FMeshMaterialReductionData*>& InData,
		/*UPackage* InPackage,*/
		const struct FSimplygonRemeshingSettings& InProxySettings,
		FRawMesh& OutProxyMesh,
		FFlattenMaterial& OutMaterial)
	{
		if (!InData.Num())
		{
			UE_LOG(LogSimplygon, Log, TEXT("The selected meshes are not valid. Make sure to select static meshes only."));
			OutProxyMesh.Empty();
			return;
		}

		//Create a Simplygon Scene
		SimplygonSDK::spScene Scene = SDK->CreateScene();
		SimplygonSDK::spGeometryValidator GeometryValidator = SDK->CreateGeometryValidator();

		//For each raw mesh in array create a scene mesh and populate with geometry data
		for (int32 MeshIndex = 0; MeshIndex < InData.Num(); ++MeshIndex)
		{
			SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromRawMesh(*InData[MeshIndex]->Mesh, InData[MeshIndex]->TexcoordBounds, InData[MeshIndex]->NewUVs);
			if (!GeometryData)
			{
				UE_LOG(LogSimplygon, Warning, TEXT("Geometry data is NULL"));
				continue;
			}

			GeometryData->CleanupNanValues();

			//Validate Geometery
			ValidateGeometry(GeometryValidator, GeometryData);

			check(GeometryData)

				SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();
			Mesh->SetGeometry(GeometryData);
			Mesh->SetName(TCHAR_TO_ANSI(*FString::Printf(TEXT("UnrealMesh%d"), MeshIndex)));
			Scene->GetRootNode()->AddChild(Mesh);
		}

#ifdef DEBUG_PROXY_MESH
		SimplygonSDK::spWavefrontExporter objexp = SDK->CreateWavefrontExporter();
		objexp->SetExportFilePath("d:/BeforeAggregateMesh.obj");
		objexp->SetScene(Scene);
		objexp->RunExport();
#endif

		//Create and setup the Aggregator
		SimplygonSDK::spAggregationProcessor AggregationProcessor = SDK->CreateAggregationProcessor();
		AggregationProcessor->SetScene(Scene);
		AggregationProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);

		// Process data
		SimplygonProcessMassiveLOD(AggregationProcessor, InData, InProxySettings.MaterialLODSettings, OutMaterial);

		//Collect the proxy mesh
		SimplygonSDK::spSceneMesh AggregatedMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>(Scene->GetRootNode()->GetChild(0));

#ifdef DEBUG_PROXY_MESH
		SimplygonSDK::spWavefrontExporter objexp = SDK->CreateWavefrontExporter();
		objexp->SetExportFilePath("d:/AfterAggregateMesh.obj");
		objexp->SetScene(Scene);
		objexp->RunExport();
#endif

		//Get geometry data from scene mesh
		//SimplygonSDK::spGeometryData outGeom = AggregatedMesh->GetGeometry();

		//@TODO: Use chart aggregator for lightmap UVs instead
		//Always generate a unique UV layout for lightmaps
		//SimplygonSDK::spRealArray LightmapUV = SDK->CreateRealArray();
		//LightmapUV->DeepCopy(outGeom->GetTexCoords(0));
		//SimplygonSDK::spParameterizer SgParameterizer = SDK->CreateParameterizer();
		//SgParameterizer->SetMaxStretch(0.8f);
		//SgParameterizer->SetTextureWidth(512);
		//SgParameterizer->SetTextureHeight(512);
		//SgParameterizer->SetGutterSpace(1);
		//SgParameterizer->SetFeatureFlagsMask(0);
		//bool bSuccess = SgParameterizer->Parameterize(outGeom, LightmapUV);

		//if (bSuccess)
		//{
		//	//Find an empty slot to put the UVs in
		//	for (int32 UVIndex = 0; UVIndex < MAX_MESH_TEXTURE_COORDS; ++UVIndex)
		//	{
		//		SimplygonSDK::spRealArray TempUVs = outGeom->GetTexCoords(UVIndex);
		//		if (TempUVs.IsNull())
		//		{
		//			outGeom->AddTexCoords(UVIndex);
		//			outGeom->GetTexCoords(UVIndex)->DeepCopy(LightmapUV);
		//			break;
		//		}
		//	}
		//}

		//Convert geometry data to raw mesh data
		CreateRawMeshFromGeometry_Proxy(OutProxyMesh, AggregatedMesh->GetGeometry(), WINDING_Keep);
	}

	//@TODO: Add possibility to choose between the parameterizer and chart aggregator
	virtual bool GenerateUniqueUVs(FRawMesh& RawMesh,
		uint32 TexCoordIndex,
		float MaxDesiredStretch,
		uint32 DesiredTextureWidth,
		uint32 DesiredTextureHeight,
		uint32 DesiredGutterSpace)
	{
		bool bSuccess = false;

		SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromRawMesh(RawMesh);
		check(GeometryData);

		SimplygonSDK::spWelder Welder = SDK->CreateWelder();
		Welder->SetWeldDist(0.0f);
		Welder->WeldGeometry(GeometryData);

		SimplygonSDK::spRealArray NewUVs = SDK->CreateRealArray();
		NewUVs->DeepCopy(GeometryData->GetTexCoords(0));

		SimplygonSDK::spParameterizer SgParameterizer = SDK->CreateParameterizer();
		SgParameterizer->SetMaxStretch(MaxDesiredStretch);
		SgParameterizer->SetTextureWidth(DesiredTextureWidth);
		SgParameterizer->SetTextureHeight(DesiredTextureHeight);
		SgParameterizer->SetGutterSpace(DesiredGutterSpace);
		SgParameterizer->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
		bSuccess = SgParameterizer->Parameterize(GeometryData, NewUVs);

		//SimplygonSDK::spChartAggregator SgChartAggregator = SDK->CreateChartAggregator();

		if (bSuccess)
		{

			SimplygonSDK::spRealArray ExistingUVs = GeometryData->GetTexCoords(TexCoordIndex);
			if (ExistingUVs)
			{
				GeometryData->RemoveTexCoords(TexCoordIndex);
			}
			GeometryData->AddTexCoords(TexCoordIndex);
			GeometryData->GetTexCoords(TexCoordIndex)->DeepCopy(NewUVs);

			CreateRawMeshFromGeometry(RawMesh, GeometryData, WINDING_Keep);
		}

		return bSuccess;
	}

	//todo: currently GenerateUniqueUVs is distributed between 3 modules, in call order:
	// 1. SimplygonUtilities - named with prefix "Simplygon...", not needed to be there - just wrappers around functions located here
	// 2. SimplygonMeshReduction (here) - because it wants CreateGeometryFromRawMesh and CreateGeometryFromSkeletalLODModel
	// 3. MeshUtilities - because this module contains private FLayoutUV class.
	// That would be nice to combine them, or at least remove one of them.
	virtual bool GenerateUniqueUVs(
		const FRawMesh& RawMesh,
		float MaxDesiredStretch,
		uint32 DesiredTextureWidth,
		uint32 DesiredTextureHeight,
		uint32 DesiredGutterSpace,
		TArray<FVector2D>& OutTexCoords)
	{
#if USE_FLAYOUT_UV
		IMeshUtilities& MeshUtilities = FModuleManager::Get().LoadModuleChecked<IMeshUtilities>("MeshUtilities");
		if (MeshUtilities.GenerateUniqueUVsForStaticMesh(RawMesh, FMath::Max(DesiredTextureWidth, DesiredTextureHeight), OutTexCoords))
		{
			return true;
		}
#endif
		bool bSuccess = false;

		SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromRawMesh(RawMesh);
		check(GeometryData);

		SimplygonSDK::spWelder Welder = SDK->CreateWelder();
		Welder->SetWeldDist(0.0f);
		Welder->WeldGeometry(GeometryData);

		SimplygonSDK::spRealArray NewUVs = SDK->CreateRealArray();
		NewUVs->DeepCopy(GeometryData->GetTexCoords(0));

#if !USE_SIMPLYGON_CHART_AGGREGATOR
		SimplygonSDK::spParameterizer SgParameterizer = SDK->CreateParameterizer();
		SgParameterizer->SetMaxStretch(MaxDesiredStretch);
#else
		SimplygonSDK::spChartAggregator SgParameterizer = SDK->CreateChartAggregator();
		SgParameterizer->SetSeparateOverlappingCharts(true);
		SgParameterizer->SetUseAreaWeighting(true);
		SgParameterizer->SetTexCoordLevel(0);
		SgParameterizer->SetKeepOriginalChartSizes(false);
		SgParameterizer->SetKeepOriginalChartProportions(false);
#endif

		SgParameterizer->SetTextureWidth(DesiredTextureWidth);
		SgParameterizer->SetTextureHeight(DesiredTextureHeight);
		SgParameterizer->SetGutterSpace(DesiredGutterSpace);
		SgParameterizer->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
		bSuccess = SgParameterizer->Parameterize(GeometryData, NewUVs);

		if (bSuccess)
		{
			int32 NumWedges = RawMesh.WedgeIndices.Num();
			check(NumWedges == GeometryData->GetTriangleCount() * 3);
			OutTexCoords.Empty(NumWedges);
			OutTexCoords.AddUninitialized(NumWedges);

			SimplygonSDK::spRealData DestTexCoord = SDK->CreateRealData();
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				//NewUVs->GetTuple(WedgeIndex, (float*)&OutTexCoords[WedgeIndex]);
				NewUVs->GetTuple(WedgeIndex, DestTexCoord);
				SimplygonSDK::real* sgTexCoords = DestTexCoord->GetData();

				OutTexCoords[WedgeIndex].X = sgTexCoords[0];
				OutTexCoords[WedgeIndex].Y = sgTexCoords[1];
			}
		}

		return bSuccess;
	}

	virtual bool GenerateUniqueUVs(
		const FStaticLODModel& LODModel,
		const FReferenceSkeleton& RefSkeleton,
		float MaxDesiredStretch,
		uint32 DesiredTextureWidth,
		uint32 DesiredTextureHeight,
		uint32 DesiredGutterSpace,
		TArray<FVector2D>& OutTexCoords)
	{
#if USE_FLAYOUT_UV
		IMeshUtilities& MeshUtilities = FModuleManager::Get().LoadModuleChecked<IMeshUtilities>("MeshUtilities");
		if (MeshUtilities.GenerateUniqueUVsForSkeletalMesh(LODModel, FMath::Max(DesiredTextureWidth, DesiredTextureHeight), OutTexCoords))
		{
			return true;
		}
#endif

		bool bSuccess = false;

		SimplygonSDK::spScene Scene = SDK->CreateScene();
		check(Scene);

		// Create bone hierarchy for simplygon.
		TArray<SimplygonSDK::rid> BoneTableIDs;
		CreateSkeletalHierarchy(Scene, RefSkeleton, BoneTableIDs);

		// Create a new scene mesh object
		SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromSkeletalLODModel(Scene, LODModel, BoneTableIDs);
		check(GeometryData);

		SimplygonSDK::spWelder Welder = SDK->CreateWelder();
		Welder->SetWeldDist(0.0f);
		Welder->WeldGeometry(GeometryData);

		SimplygonSDK::spRealArray NewUVs = SDK->CreateRealArray();
		NewUVs->DeepCopy(GeometryData->GetTexCoords(0));

#if !USE_SIMPLYGON_CHART_AGGREGATOR
		SimplygonSDK::spParameterizer SgParameterizer = SDK->CreateParameterizer();
		SgParameterizer->SetMaxStretch(MaxDesiredStretch);
		//		SgParameterizer->SetPackingEfficency(1.0f); // default value is 0.1
#else
		SimplygonSDK::spChartAggregator SgParameterizer = SDK->CreateChartAggregator();
		SgParameterizer->SetSeparateOverlappingCharts(true);
		SgParameterizer->SetUseAreaWeighting(true);
		SgParameterizer->SetTexCoordLevel(0);
		SgParameterizer->SetKeepOriginalChartSizes(false);
		SgParameterizer->SetKeepOriginalChartProportions(false);
#endif

		SgParameterizer->SetTextureWidth(DesiredTextureWidth);
		SgParameterizer->SetTextureHeight(DesiredTextureHeight);
		SgParameterizer->SetGutterSpace(DesiredGutterSpace);
		SgParameterizer->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
		bSuccess = SgParameterizer->Parameterize(GeometryData, NewUVs);

		if (bSuccess)
		{
			// Generated texture coordinates doesn't share vertices, so store one UV per one corner (i.e. per index buffer element)
			int32 NumVertices = LODModel.GetTotalFaces() * 3;
			OutTexCoords.Empty(NumVertices);
			OutTexCoords.AddUninitialized(NumVertices);

			SimplygonSDK::spRealData DestTexCoord = SDK->CreateRealData();
			for (int32 Index = 0; Index < NumVertices; Index++)
			{
				//NewUVs->GetTuple(Index, (float*)&OutTexCoords[Index]);
				NewUVs->GetTuple(Index, DestTexCoord);
				SimplygonSDK::real* sgTexCoords = DestTexCoord->GetData();

				OutTexCoords[Index].X = sgTexCoords[0];
				OutTexCoords[Index].Y = sgTexCoords[1];
			}
		}

		return bSuccess;
	}

	//@third party code END SIMPLYGON

	// IMeshMerging interface
	virtual void BuildProxy(
		const TArray<FRawMesh>& InputMeshes,
		const TArray<FFlattenMaterial>& InputMaterials,
		const struct FMeshProxySettings& InProxySettings,
		FRawMesh& OutProxyMesh,
		FFlattenMaterial& OutMaterial) override
	{
		if (InputMeshes.Num() == 0)
		{
			return;
		}

		//Create a Simplygon Scene
		SimplygonSDK::spScene Scene = SDK->CreateScene();
		//Material table for the original materials
		SimplygonSDK::spMaterialTable OriginalMaterials = Scene->GetMaterialTable();

		//Build simplygon materials from the original asset materials
		FMaterialCastingProperties CastProperties;
		CastProperties.bCastMaterials = CreateSGMaterialFromFlattenMaterial(InputMaterials, OriginalMaterials, CastProperties);

		//For each raw mesh in array create a scene mesh and populate with geometry data
		for (int32 MeshIndex = 0; MeshIndex < InputMeshes.Num(); ++MeshIndex)
		{
			SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();
			SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromRawMesh(InputMeshes[MeshIndex]);
			GeometryData->CleanupNanValues();
			check(GeometryData)

#ifdef DEBUG_PROXY_MESH
				SimplygonSDK::spWavefrontExporter objexp = SDK->CreateWavefrontExporter();
			objexp->SetExportFilePath("d:/BeforeProxyMesh.obj");
			objexp->SetSingleGeometry(GeometryData);
			objexp->RunExport();
#endif
			Mesh->SetGeometry(GeometryData);
			Mesh->SetName(TCHAR_TO_ANSI(*FString::Printf(TEXT("Mesh%d"), MeshIndex)));
			Scene->GetRootNode()->AddChild(Mesh);
		}


		//Create a remesher
		SimplygonSDK::spRemeshingProcessor RemeshingProcessor = SDK->CreateRemeshingProcessor();

		//Setup the remesher
		RemeshingProcessor->AddObserver(&EventHandler, SimplygonSDK::SG_EVENT_PROGRESS);
		RemeshingProcessor->GetRemeshingSettings()->SetOnScreenSize(InProxySettings.ScreenSize);
		RemeshingProcessor->GetRemeshingSettings()->SetMergeDistance(InProxySettings.MergeDistance);
		//RemeshingProcessor->GetRemeshingSettings()->SetUseGroundPlane(InProxySettings.bUseClippingPlane);
		//RemeshingProcessor->GetRemeshingSettings()->SetGroundPlaneAxisIndex(InProxySettings.AxisIndex); // 0:X-Axis, 1:Y-Axis, 2:Z-Axis
		//RemeshingProcessor->GetRemeshingSettings()->SetGroundPlaneLevel(InProxySettings.ClippingLevel);

		// Goal is: If user specifies negative clipping plane -> negative halfspace should be clipped
		if (InProxySettings.AxisIndex <= 1) // Invert X and Y axis
		{
			//RemeshingProcessor->GetRemeshingSettings()->SetGroundPlaneNegativeHalfspace(!InProxySettings.bPlaneNegativeHalfspace);
		}
		else
		{
			//RemeshingProcessor->GetRemeshingSettings()->SetGroundPlaneNegativeHalfspace(InProxySettings.bPlaneNegativeHalfspace);
		}

		RemeshingProcessor->GetRemeshingSettings()->SetTransferNormals(false);
		RemeshingProcessor->GetRemeshingSettings()->SetMergeDistance(InProxySettings.MergeDistance);
		RemeshingProcessor->GetRemeshingSettings()->SetHardEdgeAngleInRadians(FMath::DegreesToRadians(InProxySettings.HardAngleThreshold));//This should be a user settings in the popup dialog!
		RemeshingProcessor->SetScene(Scene);

		//Setup the mapping image used for casting
		SimplygonSDK::spMappingImageSettings MappingSettings = RemeshingProcessor->GetMappingImageSettings();
		MappingSettings->SetGenerateMappingImage(true);
		MappingSettings->SetGenerateTexCoords(true);
		MappingSettings->SetGenerateTangents(false);

		FIntPoint MappingImageSize = ComputeMappingImageSize(InProxySettings.Material);
		MappingSettings->SetWidth(MappingImageSize.X);
		MappingSettings->SetHeight(MappingImageSize.Y);

		//Start remeshing the geometry
		RemeshingProcessor->RemeshGeometry();

		if (CastProperties.bCastMaterials)
		{
			//Collect the mapping image from the remeshing process
			SimplygonSDK::spMappingImage MappingImage = RemeshingProcessor->GetMappingImage();

			//Create a new material for the proxy geometry
			SimplygonSDK::spMaterial OutputMaterialLOD = SDK->CreateMaterial();

			//Cast diffuse texture data
			{
				//Create Image data where the diffuse data is stored
				SimplygonSDK::spImageData OutputDiffuseData = SDK->CreateImageData();
				// Cast the data using a color caster
				SimplygonSDK::spColorCaster cast = SDK->CreateColorCaster();
				cast->SetColorType(SimplygonSDK::SG_MATERIAL_CHANNEL_DIFFUSE);
				cast->SetSourceMaterials(OriginalMaterials);
				cast->SetMappingImage(MappingImage); // The mapping image we got from the remeshing process.
				cast->SetOutputChannels(4); // RGB, 3 channels! (1 would be for grey scale, and 4 would be for RGBA.)
				cast->SetOutputChannelBitDepth(8); // 8 bits per channel. So in this case we will have 24bit colors RGB.
				cast->SetDilation(10); // To avoid mip-map artifacts, the empty pixels on the map needs to be filled to a degree aswell.
				cast->SetOutputImage(OutputDiffuseData);
				cast->CastMaterials(); // Fetch!

									   // set the material properties 
									   // Set the diffuse multiplier for the texture. 1 means it will not differ from original texture,
									   // For example: 0 would ignore a specified color and 2 would make a color twice as pronounced as the others.
				OutputMaterialLOD->SetDiffuseRed(1);
				OutputMaterialLOD->SetDiffuseGreen(1);
				OutputMaterialLOD->SetDiffuseBlue(1);
				OutputMaterialLOD->SetLayeredTextureImage(SimplygonSDK::SG_MATERIAL_CHANNEL_DIFFUSE, 0, OutputDiffuseData);
				OutputMaterialLOD->SetLayeredTextureLevel(SimplygonSDK::SG_MATERIAL_CHANNEL_DIFFUSE, 0, 0);
			}

			// Normal texture data
			if (CastProperties.bCastNormals)
			{
				//Create Image data where the normal data is stored
				SimplygonSDK::spImageData OutputNormalData = SDK->CreateImageData();

				// Cast the data using a normal caster
				SimplygonSDK::spNormalCaster cast = SDK->CreateNormalCaster();
				cast->SetSourceMaterials(OriginalMaterials);
				cast->SetMappingImage(MappingImage); // The mapping image we got from the remeshing process.
				cast->SetOutputChannels(3); // RGB, 3 channels! (1 would be for grey scale, and 4 would be for RGBA.)
				cast->SetOutputChannelBitDepth(8); // 8 bits per channel. So in this case we will have 24bit colors RGB.
				cast->SetDilation(10); // To avoid mip-map artifacts, the empty pixels on the map needs to be filled to a degree aswell.
				cast->SetFlipBackfacingNormals(false);
				cast->SetGenerateTangentSpaceNormals(true);
				cast->SetOutputImage(OutputNormalData);
				cast->CastMaterials(); // Fetch!

				OutputMaterialLOD->SetLayeredTextureImage(SimplygonSDK::SG_MATERIAL_CHANNEL_NORMALS, 0, OutputNormalData);
				OutputMaterialLOD->SetLayeredTextureLevel(SimplygonSDK::SG_MATERIAL_CHANNEL_NORMALS, 0, 0);
			}

			// Metallic texture data
			if (CastProperties.bCastMetallic)
			{
				// Create Image data where the metallic data is stored
				SimplygonSDK::spImageData OutputMetallicData = SDK->CreateImageData();
				// Cast the data using a color caster
				SimplygonSDK::spColorCaster cast = SDK->CreateColorCaster();
				cast->SetColorType(USER_MATERIAL_CHANNEL_METALLIC);
				cast->SetSourceMaterials(OriginalMaterials);
				cast->SetMappingImage(MappingImage);
				cast->SetOutputChannels(3);
				cast->SetOutputChannelBitDepth(8);
				cast->SetIsSRGB(false);
				cast->SetDilation(10);
				cast->SetOutputImage(OutputMetallicData);
				cast->CastMaterials(); // Fetch!

				OutputMaterialLOD->AddUserChannel(USER_MATERIAL_CHANNEL_METALLIC);
				OutputMaterialLOD->SetLayeredTextureImage(USER_MATERIAL_CHANNEL_METALLIC, 0, OutputMetallicData);
				OutputMaterialLOD->SetLayeredTextureLevel(USER_MATERIAL_CHANNEL_METALLIC, 0, 0);
			}

			// Roughness texture data
			if (CastProperties.bCastRoughness)
			{
				// Create Image data where the metallic data is stored
				SimplygonSDK::spImageData OutputRoughnessData = SDK->CreateImageData();
				// Cast the data using a color caster
				SimplygonSDK::spColorCaster cast = SDK->CreateColorCaster();
				cast->SetColorType(USER_MATERIAL_CHANNEL_ROUGHNESS);
				cast->SetSourceMaterials(OriginalMaterials);
				cast->SetMappingImage(MappingImage);
				cast->SetOutputChannels(3);
				cast->SetOutputChannelBitDepth(8);
				cast->SetIsSRGB(false);
				cast->SetDilation(10);
				cast->SetOutputImage(OutputRoughnessData);
				cast->CastMaterials(); // Fetch!

				OutputMaterialLOD->AddUserChannel(USER_MATERIAL_CHANNEL_ROUGHNESS);
				OutputMaterialLOD->SetLayeredTextureImage(USER_MATERIAL_CHANNEL_ROUGHNESS, 0, OutputRoughnessData);
				OutputMaterialLOD->SetLayeredTextureLevel(USER_MATERIAL_CHANNEL_ROUGHNESS, 0, 0);
			}

			// Specular texture data
			if (CastProperties.bCastSpecular)
			{
				// Create Image data where the metallic data is stored
				SimplygonSDK::spImageData OutputSpecularData = SDK->CreateImageData();
				// Cast the data using a color caster
				SimplygonSDK::spColorCaster cast = SDK->CreateColorCaster();
				cast->SetColorType(USER_MATERIAL_CHANNEL_SPECULAR);
				cast->SetSourceMaterials(OriginalMaterials);
				cast->SetMappingImage(MappingImage);
				cast->SetOutputChannels(3);
				cast->SetOutputChannelBitDepth(8);
				cast->SetIsSRGB(false);
				cast->SetDilation(10);
				cast->SetOutputImage(OutputSpecularData);
				cast->CastMaterials(); // Fetch!

				OutputMaterialLOD->AddUserChannel(USER_MATERIAL_CHANNEL_SPECULAR);
				OutputMaterialLOD->SetLayeredTextureImage(USER_MATERIAL_CHANNEL_SPECULAR, 0, OutputSpecularData);
				OutputMaterialLOD->SetLayeredTextureLevel(USER_MATERIAL_CHANNEL_SPECULAR, 0, 0);
			}

			//Create a new material table for the new materials
			SimplygonSDK::spMaterialTable OutputTable = SDK->CreateMaterialTable();
			OutputTable->AddMaterial(OutputMaterialLOD);

			//Convert the simplygon material to unreal materials
			CreateFlattenMaterialFromSGMaterial(OutputTable, OutMaterial);
		}

		//Collect the proxy mesh
		SimplygonSDK::spSceneMesh ProxyMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>(Scene->GetRootNode()->GetChild(0));

#ifdef DEBUG_PROXY_MESH
		SimplygonSDK::spWavefrontExporter objexp = SDK->CreateWavefrontExporter();
		objexp->SetExportFilePath("d:/AfterProxyMesh.obj");
		objexp->SetSingleGeometry(ProxyMesh->GetGeometry());
		objexp->RunExport();
#endif

		//Convert geometry data to raw mesh data
		SimplygonSDK::spGeometryData outGeom = ProxyMesh->GetGeometry();
		CreateRawMeshFromGeometry(OutProxyMesh, ProxyMesh->GetGeometry(), WINDING_Keep);

		// Since mesh proxies have 1 texture channel
		// put copy to channel 1 for lightmaps
		OutProxyMesh.WedgeTexCoords[1].Empty();
		OutProxyMesh.WedgeTexCoords[1].Append(OutProxyMesh.WedgeTexCoords[0]);

		// Default smoothing
		OutProxyMesh.FaceSmoothingMasks.SetNum(OutProxyMesh.FaceMaterialIndices.Num());
		for (uint32& SmoothingMask : OutProxyMesh.FaceSmoothingMasks)
		{
			SmoothingMask = 1;
		}
	}

private:
	SimplygonSDK::ISimplygonSDK* SDK;
	FDefaultErrorHandler ErrorHandler;
	FDefaultEventHandler EventHandler;
	FString VersionString;

	explicit FSimplygonMeshReduction(SimplygonSDK::ISimplygonSDK* InSDK)
		: SDK(InSDK)
	{
		check(SDK);
		SDK->SetErrorHandler(&ErrorHandler);
		SDK->SetGlobalSetting("DefaultTBNType", SimplygonSDK::SG_TANGENTSPACEMETHOD_ORTHONORMAL_LEFTHANDED);
		SDK->SetGlobalSetting("AllowDirectX", true);


		const TCHAR* LibraryVersion = ANSI_TO_TCHAR(InSDK->GetVersion());
		const TCHAR* UnrealVersionGuid = TEXT("18f808c3cf724e5a994f57de5c83cc4b");
		VersionString = FString::Printf(TEXT("%s.%s_%s"), LibraryVersion, SG_UE_INTEGRATION_REV, UnrealVersionGuid);
		UE_LOG(LogSimplygon, Display, TEXT("Initialized with Simplygon %s"), *VersionString);
	}

	SimplygonSDK::spGeometryData CreateGeometryFromRawMesh(const FRawMesh& RawMesh)
	{
		int32 NumVertices = RawMesh.VertexPositions.Num();
		int32 NumWedges = RawMesh.WedgeIndices.Num();
		int32 NumTris = NumWedges / 3;

		if (NumWedges == 0)
		{
			return NULL;
		}

		SimplygonSDK::spGeometryData GeometryData = SDK->CreateGeometryData();
		GeometryData->SetVertexCount(NumVertices);
		GeometryData->SetTriangleCount(NumTris);

		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		for (int32 VertexIndex = 0; VertexIndex < NumVertices; ++VertexIndex)
		{
			FVector TempPos = RawMesh.VertexPositions[VertexIndex];
			TempPos = GetConversionMatrix().TransformPosition(TempPos);
			Positions->SetTuple(VertexIndex, (float*)&TempPos);
		}

		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
		{
			Indices->SetItem(WedgeIndex, RawMesh.WedgeIndices[WedgeIndex]);
		}

		for (int32 TexCoordIndex = 0; TexCoordIndex < MAX_MESH_TEXTURE_COORDS; ++TexCoordIndex)
		{
			if (RawMesh.WedgeTexCoords[TexCoordIndex].Num() == NumWedges)
			{
				GeometryData->AddTexCoords(TexCoordIndex);
				SimplygonSDK::spRealArray TexCoords = GeometryData->GetTexCoords(TexCoordIndex);
				check(TexCoords->GetTupleSize() == 2);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					TexCoords->SetTuple(WedgeIndex, (float*)&RawMesh.WedgeTexCoords[TexCoordIndex][WedgeIndex]);
				}
			}
		}

		if (RawMesh.WedgeColors.Num() == NumWedges)
		{
			GeometryData->AddColors(0);
			SimplygonSDK::spRealArray LinearColors = GeometryData->GetColors(0);
			check(LinearColors);
			check(LinearColors->GetTupleSize() == 4);
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				FLinearColor LinearColor(RawMesh.WedgeColors[WedgeIndex]);
				LinearColors->SetTuple(WedgeIndex, (float*)&LinearColor);
			}
		}

		if (RawMesh.WedgeTangentZ.Num() == NumWedges)
		{
			if (RawMesh.WedgeTangentX.Num() == NumWedges && RawMesh.WedgeTangentY.Num() == NumWedges)
			{
				GeometryData->AddTangents(0);
				SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					FVector TempTangent = RawMesh.WedgeTangentX[WedgeIndex];
					TempTangent = GetConversionMatrix().TransformPosition(TempTangent);
					Tangents->SetTuple(WedgeIndex, (float*)&TempTangent);
				}

				GeometryData->AddBitangents(0);
				SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					FVector TempBitangent = RawMesh.WedgeTangentY[WedgeIndex];
					TempBitangent = GetConversionMatrix().TransformPosition(TempBitangent);
					Bitangents->SetTuple(WedgeIndex, (float*)&TempBitangent);
				}
			}
			GeometryData->AddNormals();
			SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				FVector TempNormal = RawMesh.WedgeTangentZ[WedgeIndex];
				TempNormal = GetConversionMatrix().TransformPosition(TempNormal);
				Normals->SetTuple(WedgeIndex, (float*)&TempNormal);
			}
		}

		// Per-triangle data.
		GeometryData->AddMaterialIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
		{
			MaterialIndices->SetItem(TriIndex, RawMesh.FaceMaterialIndices[TriIndex]);
		}

		GeometryData->AddGroupIds();
		SimplygonSDK::spRidArray GroupIds = GeometryData->GetGroupIds();
		for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
		{
			GroupIds->SetItem(TriIndex, RawMesh.FaceSmoothingMasks[TriIndex]);
		}

		return GeometryData;

	}

	//@third party code BEGIN SIMPLYGON
	// This is a copy of CreateGeometryFromRawMesh with additional features for material LOD.
	SimplygonSDK::spGeometryData CreateGeometryFromRawMesh(const FRawMesh& RawMesh, const FBox2D& TextureBounds, const TArray<FVector2D>& InTexCoords)
	{
		int32 NumVertices = RawMesh.VertexPositions.Num();
		int32 NumWedges = RawMesh.WedgeIndices.Num();
		int32 NumTris = NumWedges / 3;

		if (NumWedges == 0)
		{
			return NULL;
		}

		SimplygonSDK::spGeometryData GeometryData = SDK->CreateGeometryData();
		GeometryData->SetVertexCount(NumVertices);
		GeometryData->SetTriangleCount(NumTris);

		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		for (int32 VertexIndex = 0; VertexIndex < NumVertices; ++VertexIndex)
		{
			FVector TempPos = RawMesh.VertexPositions[VertexIndex];
			TempPos = GetConversionMatrix().TransformPosition(TempPos);
			Positions->SetTuple(VertexIndex, (float*)&TempPos);
		}

		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
		{
			Indices->SetItem(WedgeIndex, RawMesh.WedgeIndices[WedgeIndex]);
		}

		for (int32 TexCoordIndex = 0; TexCoordIndex < MAX_MESH_TEXTURE_COORDS; ++TexCoordIndex)
		{
			const TArray<FVector2D>& SrcTexCoords = (TexCoordIndex == 0 && InTexCoords.Num() == NumWedges) ? InTexCoords : RawMesh.WedgeTexCoords[TexCoordIndex];
			if (SrcTexCoords.Num() == NumWedges)
			{
				GeometryData->AddTexCoords(TexCoordIndex);
				SimplygonSDK::spRealArray TexCoords = GeometryData->GetTexCoords(TexCoordIndex);
				check(TexCoords->GetTupleSize() == 2);
				int32 WedgeIndex = 0;
				for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
				{
					int32 MaterialIndex = RawMesh.FaceMaterialIndices[TriIndex];
					// Compute texture bounds for current material.
					float MinU = 0, ScaleU = 1;
					float MinV = 0, ScaleV = 1;
					if (TextureBounds.bIsValid && TexCoordIndex == 0 && InTexCoords.Num() == 0)
					{
						if (TextureBounds.GetArea() > 0)
						{
							MinU = TextureBounds.Min.X;
							MinV = TextureBounds.Min.Y;
							ScaleU = 1.0f / (TextureBounds.Max.X - TextureBounds.Min.X);
							ScaleV = 1.0f / (TextureBounds.Max.Y - TextureBounds.Min.Y);
						}
					}
					for (int32 CornerIndex = 0; CornerIndex < 3; ++CornerIndex, ++WedgeIndex)
					{
						const FVector2D& TexCoord = SrcTexCoords[WedgeIndex];
						float UV[2];
						UV[0] = (TexCoord.X - MinU) * ScaleU;
						UV[1] = (TexCoord.Y - MinV) * ScaleV;
						TexCoords->SetTuple(WedgeIndex, UV);
					}
				}
			}
		}

		if (RawMesh.WedgeColors.Num() == NumWedges)
		{
			GeometryData->AddColors(0);
			SimplygonSDK::spRealArray LinearColors = GeometryData->GetColors(0);
			check(LinearColors);
			check(LinearColors->GetTupleSize() == 4);
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				FLinearColor LinearColor(RawMesh.WedgeColors[WedgeIndex]);
				LinearColors->SetTuple(WedgeIndex, (float*)&LinearColor);
			}
		}

		if (RawMesh.WedgeTangentZ.Num() == NumWedges)
		{
			if (RawMesh.WedgeTangentX.Num() == NumWedges && RawMesh.WedgeTangentY.Num() == NumWedges)
			{
				GeometryData->AddTangents(0);
				SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					FVector TempTangent = RawMesh.WedgeTangentX[WedgeIndex];
					TempTangent = GetConversionMatrix().TransformPosition(TempTangent);
					Tangents->SetTuple(WedgeIndex, (float*)&TempTangent);
				}

				GeometryData->AddBitangents(0);
				SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					FVector TempBitangent = RawMesh.WedgeTangentY[WedgeIndex];
					TempBitangent = GetConversionMatrix().TransformPosition(TempBitangent);
					Bitangents->SetTuple(WedgeIndex, (float*)&TempBitangent);
				}
			}
			GeometryData->AddNormals();
			SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				FVector TempNormal = RawMesh.WedgeTangentZ[WedgeIndex];
				TempNormal = GetConversionMatrix().TransformPosition(TempNormal);
				Normals->SetTuple(WedgeIndex, (float*)&TempNormal);
			}
		}

		// Per-triangle data.
		GeometryData->AddMaterialIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
		{
			MaterialIndices->SetItem(TriIndex, RawMesh.FaceMaterialIndices[TriIndex]);
		}

		GeometryData->AddGroupIds();
		SimplygonSDK::spRidArray GroupIds = GeometryData->GetGroupIds();
		for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
		{
			GroupIds->SetItem(TriIndex, RawMesh.FaceSmoothingMasks[TriIndex]);
		}

		return GeometryData;

	}
	//@third party code END SIMPLYGON 

	void CreateRawMeshFromGeometry(FRawMesh& OutRawMesh, const SimplygonSDK::spGeometryData& GeometryData, EWindingMode WindingMode)
	{
		check(GeometryData);

		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		SimplygonSDK::spRidArray GroupIds = GeometryData->GetGroupIds();
		SimplygonSDK::spRealArray LinearColors = GeometryData->GetColors(0);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);

		check(Positions);
		check(Indices);

		FRawMesh& RawMesh = OutRawMesh;
		const bool bReverseWinding = (WindingMode == WINDING_Reverse);
		int32 NumTris = GeometryData->GetTriangleCount();
		int32 NumWedges = NumTris * 3;
		int32 NumVertices = GeometryData->GetVertexCount();

		RawMesh.VertexPositions.Empty(NumVertices);
		RawMesh.VertexPositions.AddUninitialized(NumVertices);
		SimplygonSDK::spRealData sgTuple = SDK->CreateRealData();
		for (int32 VertexIndex = 0; VertexIndex < NumVertices; ++VertexIndex)
		{
			//Positions->GetTuple(VertexIndex, (float*)&RawMesh.VertexPositions[VertexIndex]);
			Positions->GetTuple(VertexIndex, sgTuple);
			SimplygonSDK::real* vertexPos = sgTuple->GetData();
			RawMesh.VertexPositions[VertexIndex] = GetConversionMatrix().TransformPosition(FVector(vertexPos[0], vertexPos[1], vertexPos[2]));
		}

		RawMesh.WedgeIndices.Empty(NumWedges);
		RawMesh.WedgeIndices.AddUninitialized(NumWedges);
		for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
		{
			for (int32 CornerIndex = 0; CornerIndex < 3; ++CornerIndex)
			{
				const uint32 DestIndex = bReverseWinding ? (2 - CornerIndex) : CornerIndex;
				RawMesh.WedgeIndices[TriIndex * 3 + DestIndex] = Indices->GetItem(TriIndex * 3 + CornerIndex);
			}
		}

		for (int32 TexCoordIndex = 0; TexCoordIndex < MAX_MESH_TEXTURE_COORDS; ++TexCoordIndex)
		{
			SimplygonSDK::spRealArray TexCoords = GeometryData->GetTexCoords(TexCoordIndex);
			if (TexCoords)
			{
				RawMesh.WedgeTexCoords[TexCoordIndex].Empty(NumWedges);
				RawMesh.WedgeTexCoords[TexCoordIndex].AddUninitialized(NumWedges);
				for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
				{
					for (int32 CornerIndex = 0; CornerIndex < 3; ++CornerIndex)
					{
						const uint32 DestIndex = bReverseWinding ? (2 - CornerIndex) : CornerIndex;
						//TexCoords->GetTuple(TriIndex * 3 + CornerIndex, (float*)&RawMesh.WedgeTexCoords[TexCoordIndex][TriIndex * 3 + DestIndex]);
						TexCoords->GetTuple(TriIndex * 3 + CornerIndex, sgTuple);

						SimplygonSDK::real* sgTextCoors = sgTuple->GetData();
						RawMesh.WedgeTexCoords[TexCoordIndex][TriIndex * 3 + DestIndex] = FVector2D(sgTextCoors[0], sgTextCoors[1]);

					}
				}
			}
		}

		//If we don't do this, corrupt LODs might be generated and cought inside: FRawMesh::IsValid()
		RawMesh.WedgeColors.Empty(NumWedges);
		if (LinearColors)
		{
			RawMesh.WedgeColors.AddUninitialized(NumWedges);
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				//LinearColors->GetTuple(WedgeIndex, (float*)&LinearColor);
				LinearColors->GetTuple(WedgeIndex, sgTuple);
				SimplygonSDK::real* sgVertexColor = sgTuple->GetData();
				FLinearColor LinearColor(sgVertexColor[0], sgVertexColor[1], sgVertexColor[2], sgVertexColor[3]);
				RawMesh.WedgeColors[WedgeIndex] = LinearColor.ToFColor(true);
			}
		}

		if (Normals)
		{
			if (Tangents && Bitangents)
			{
				RawMesh.WedgeTangentX.Empty(NumWedges);
				RawMesh.WedgeTangentX.AddUninitialized(NumWedges);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					//Tangents->GetTuple(WedgeIndex, (float*)&RawMesh.WedgeTangentX[WedgeIndex]);
					Tangents->GetTuple(WedgeIndex, sgTuple);
					SimplygonSDK::real* sgTangents = sgTuple->GetData();
					RawMesh.WedgeTangentX[WedgeIndex] = GetConversionMatrix().TransformPosition(FVector(sgTangents[0], sgTangents[1], sgTangents[2]));
				}

				RawMesh.WedgeTangentY.Empty(NumWedges);
				RawMesh.WedgeTangentY.AddUninitialized(NumWedges);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					//Bitangents->GetTuple(WedgeIndex, (float*)&RawMesh.WedgeTangentY[WedgeIndex]);
					Bitangents->GetTuple(WedgeIndex, sgTuple);
					SimplygonSDK::real* sgBitangents = sgTuple->GetData();
					RawMesh.WedgeTangentY[WedgeIndex] = GetConversionMatrix().TransformPosition(FVector(sgBitangents[0], sgBitangents[1], sgBitangents[2]));
				}
			}

			RawMesh.WedgeTangentZ.Empty(NumWedges);
			RawMesh.WedgeTangentZ.AddUninitialized(NumWedges);
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				//Normals->GetTuple(WedgeIndex, (float*)&RawMesh.WedgeTangentZ[WedgeIndex]);
				Normals->GetTuple(WedgeIndex, sgTuple);
				SimplygonSDK::real* sgNormal = sgTuple->GetData();
				RawMesh.WedgeTangentZ[WedgeIndex] = GetConversionMatrix().TransformPosition(FVector(sgNormal[0], sgNormal[1], sgNormal[2]));
			}
		}

		RawMesh.FaceMaterialIndices.Empty(NumTris);
		RawMesh.FaceMaterialIndices.AddZeroed(NumTris);
		if (MaterialIndices)
		{
			for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
			{
				RawMesh.FaceMaterialIndices[TriIndex] = MaterialIndices->GetItem(TriIndex);
			}
		}

		RawMesh.FaceSmoothingMasks.Empty(NumTris);
		RawMesh.FaceSmoothingMasks.AddZeroed(NumTris);
		if (GroupIds)
		{
			for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
			{
				RawMesh.FaceSmoothingMasks[TriIndex] = GroupIds->GetItem(TriIndex);
			}
		}
	}

	void SetReductionSettings(SimplygonSDK::spReductionSettings ReductionSettings, const FMeshReductionSettings& Settings, int32 NumTris)
	{
		float MaxDeviation = Settings.MaxDeviation > 0.0f ? Settings.MaxDeviation : SimplygonSDK::REAL_MAX;
		float MinReductionRatio = FMath::Max<float>(1.0f / NumTris, 0.05f);
		float MaxReductionRatio = (Settings.MaxDeviation > 0.0f && Settings.PercentTriangles == 1.0f) ? MinReductionRatio : 1.0f;
		float ReductionRatio = FMath::Clamp(Settings.PercentTriangles, MinReductionRatio, MaxReductionRatio);

		const float ImportanceTable[] =
		{
			0.0f,	// OFF
			0.125f,	// Lowest
			0.35f,	// Low,
			1.0f,	// Normal
			2.8f,	// High
			8.0f,	// Highest
		};

		static_assert(ARRAY_COUNT(ImportanceTable) == (EMeshFeatureImportance::Highest + 1), "Importance table size mismatch."); // -1 because of TEMP_BROKEN(?)
		check(Settings.SilhouetteImportance < EMeshFeatureImportance::Highest + 1); // -1 because of TEMP_BROKEN(?)
		check(Settings.TextureImportance < EMeshFeatureImportance::Highest + 1); // -1 because of TEMP_BROKEN(?)
		check(Settings.ShadingImportance < EMeshFeatureImportance::Highest + 1); // -1 because of TEMP_BROKEN(?)
		check(Settings.VertexColorImportance < EMeshFeatureImportance::Highest + 1); // -1 because of TEMP_BROKEN(?)

		ReductionSettings->SetStopCondition(SimplygonSDK::SG_STOPCONDITION_ANY);
		ReductionSettings->SetReductionTargets(SimplygonSDK::SG_REDUCTIONTARGET_TRIANGLERATIO | SimplygonSDK::SG_REDUCTIONTARGET_MAXDEVIATION);
		ReductionSettings->SetMaxDeviation(MaxDeviation);
		ReductionSettings->SetTriangleRatio(ReductionRatio);
		ReductionSettings->SetGeometryImportance(ImportanceTable[Settings.SilhouetteImportance]);
		ReductionSettings->SetTextureImportance(ImportanceTable[Settings.TextureImportance]);
		ReductionSettings->SetMaterialImportance(ImportanceTable[Settings.TextureImportance]);
		ReductionSettings->SetShadingImportance(ImportanceTable[Settings.ShadingImportance]);
		ReductionSettings->SetVertexColorImportance(ImportanceTable[Settings.VertexColorImportance]);
		////ReductionSettings->SetAllowDirectX(true);

		//Automatic Symmetry Detection
		ReductionSettings->SetKeepSymmetry(Settings.bKeepSymmetry);
		ReductionSettings->SetUseAutomaticSymmetryDetection(Settings.bKeepSymmetry);

		//Set reposition vertices to be enabled by default
		ReductionSettings->SetDataCreationPreferences(2); //2 = reposition vertices enabled
		ReductionSettings->SetGenerateGeomorphData(true);
	}

	void SetNormalSettings(SimplygonSDK::spNormalCalculationSettings NormalSettings, const FMeshReductionSettings& Settings)
	{
		NormalSettings->SetReplaceNormals(Settings.bRecalculateNormals);
		NormalSettings->SetScaleByArea(false);
		NormalSettings->SetScaleByAngle(false);
		NormalSettings->SetHardEdgeAngleInRadians(FMath::DegreesToRadians(Settings.HardAngleThreshold));
	}

	/**
	* Creates a Simplygon scene representation of the skeletal hierarchy.
	* @param InScene - The Simplygon scene.
	* @param InSkeleton - The skeletal hierarchy from which to create the Simplygon representation.
	* @param OutBoneTableIDs - A mapping of Bone IDs from RefSkeleton to Simplygon Bone Table IDs
	*/
	void CreateSkeletalHierarchy(SimplygonSDK::spScene& InScene, const FReferenceSkeleton& InSkeleton, TArray<SimplygonSDK::rid>& OutBoneTableIDs)
	{
		TArray<SimplygonSDK::spSceneBone> BoneArray;

		//Create Simplygon scene nodes for each bone in our Skeletal Hierarchy
		for (int32 BoneIndex = 0; BoneIndex < InSkeleton.GetNum(); ++BoneIndex)
		{
			SimplygonSDK::spSceneBone SceneBone = SDK->CreateSceneBone();
			BoneArray.Add(SceneBone);
		}

		SimplygonSDK::spSceneBoneTable BoneTable = InScene->GetBoneTable();
		for (int32 BoneIndex = 0; BoneIndex < InSkeleton.GetNum(); ++BoneIndex)
		{
			int32 ParentIndex = InSkeleton.GetParentIndex(BoneIndex);
			SimplygonSDK::spSceneBone CurrentBone = BoneArray[BoneIndex];

			//@third party code BEGIN SIMPLYGON
			/*if(InBoneTree[BoneIndex].bLockBone)
			{
			CurrentBone->SetLockFromBoneLOD(true);
			}

			if(InBoneTree[BoneIndex].bRemoveBone)
			{
			CurrentBone->SetForceBoneRemoval(true);
			}*/
			//@third party code END SIMPLYGON

			//We add the bone to the scene's bone table. This returns a uid that we must apply to the geometry data.
			SimplygonSDK::rid BoneID = BoneTable->AddBone(CurrentBone);
			OutBoneTableIDs.Add(BoneID);

			//Handle root bone. Add to Scene root.
			if (BoneIndex == 0)
			{
				InScene->GetRootNode()->AddChild(CurrentBone);
			}
			else
			{
				SimplygonSDK::spSceneBone ParentBone = BoneArray[ParentIndex];
				ParentBone->AddChild(CurrentBone);
			}
		}
	}

	/**
	* Creates a Simplygon geometry representation from a skeletal mesh LOD model.
	* @param Scene - The Simplygon scene.
	* @param LODModel - The skeletal mesh LOD model from which to create the geometry data.
	* @param BoneIDs - A maps of Bone IDs from RefSkeleton to Simplygon BoneTable IDs
	* @returns a Simplygon geometry data representation of the skeletal mesh LOD.
	*/
	SimplygonSDK::spGeometryData CreateGeometryFromSkeletalLODModel(SimplygonSDK::spScene& Scene, const FStaticLODModel& LODModel, const TArray<SimplygonSDK::rid>& BoneIDs)
	{
		TArray<FSoftSkinVertex> Vertices;
		FMultiSizeIndexContainerData IndexData;
		LODModel.GetVertices(Vertices);
		LODModel.MultiSizeIndexContainer.GetIndexBufferData(IndexData);

		const uint32 VertexCount = LODModel.NumVertices;
		const uint32 TexCoordCount = LODModel.NumTexCoords;
		check(TexCoordCount <= MAX_TEXCOORDS);

		uint32 TriCount = 0;
#if WITH_APEX_CLOTHING
		const uint32 SectionCount = (uint32)LODModel.NumNonClothingSections();
#else
		const uint32 SectionCount = LODModel.Sections.Num();
#endif // #if WITH_APEX_CLOTHING
		for (uint32 SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex)
		{
			TriCount += LODModel.Sections[SectionIndex].NumTriangles;
		}

		SimplygonSDK::spGeometryData GeometryData = SDK->CreateGeometryData();
		GeometryData->SetVertexCount(VertexCount);
		GeometryData->SetTriangleCount(TriCount);

		// Per-vertex data.
		GeometryData->AddBoneIds(MAX_TOTAL_INFLUENCES);
		GeometryData->AddBoneWeights(MAX_TOTAL_INFLUENCES);
		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray BoneIds = GeometryData->GetBoneIds();
		SimplygonSDK::spRealArray BoneWeights = GeometryData->GetBoneWeights();

		// Per-corner per-triangle data.
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRealArray TexCoords[MAX_TEXCOORDS];
		for (uint32 TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex)
		{
			GeometryData->AddTexCoords(TexCoordIndex);
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords(TexCoordIndex);
			check(TexCoords[TexCoordIndex]->GetTupleSize() == 2);
		}
		GeometryData->AddNormals();
		GeometryData->AddTangents(0);
		GeometryData->AddBitangents(0);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);

		SimplygonSDK::spUnsignedCharArray Colors;
		if (LODModel.ColorVertexBuffer.GetNumVertices() == VertexCount)
		{
			GeometryData->AddBaseTypeUserTriangleVertexField(SimplygonSDK::TYPES_ID_UCHAR, SIMPLYGON_COLOR_CHANNEL, 4);
			SimplygonSDK::spValueArray ColorValues = GeometryData->GetUserTriangleVertexField(SIMPLYGON_COLOR_CHANNEL);
			check(ColorValues);
			Colors = SimplygonSDK::IUnsignedCharArray::SafeCast(ColorValues);
			check(Colors);
		}

		// Per-triangle data.
		GeometryData->AddMaterialIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();

		// Add per-vertex data. This data needs to be added per-chunk so that we can properly map bones.
#if WITH_APEX_CLOTHING
		const int32 ChunkCount = LODModel.NumNonClothingSections();
#else
		const int32 ChunkCount = LODModel.Chunks.Num();
#endif // #if WITH_APEX_CLOTHING
		uint32 FirstVertex = 0;
		for (int32 ChunkIndex = 0; ChunkIndex < ChunkCount; ++ChunkIndex)
		{
			const FSkelMeshChunk& Chunk = LODModel.Chunks[ChunkIndex];
			const uint32 LastVertex = FirstVertex + (uint32)Chunk.RigidVertices.Num() + (uint32)Chunk.SoftVertices.Num();
			for (uint32 VertexIndex = FirstVertex; VertexIndex < LastVertex; ++VertexIndex)
			{
				FSoftSkinVertex& Vertex = Vertices[VertexIndex];
				SimplygonSDK::rid VertexBoneIds[MAX_TOTAL_INFLUENCES];
				SimplygonSDK::real VertexBoneWeights[MAX_TOTAL_INFLUENCES];

				uint32 TotalInfluence = 0;
				for (uint32 InfluenceIndex = 0; InfluenceIndex < MAX_TOTAL_INFLUENCES; ++InfluenceIndex)
				{
					int32 BoneIndex = Vertex.InfluenceBones[InfluenceIndex];
					const uint8 BoneInfluence = Vertex.InfluenceWeights[InfluenceIndex];
					TotalInfluence += BoneInfluence;

					if (BoneInfluence > 0)
					{
						check(BoneIndex < Chunk.BoneMap.Num());
						uint32 BoneID = BoneIDs[Chunk.BoneMap[BoneIndex]];
						VertexBoneIds[InfluenceIndex] = BoneID;
						VertexBoneWeights[InfluenceIndex] = BoneInfluence / 255.0f;
					}
					else
					{
						//Set BoneID and BoneWeight to -1 and 0 respectively as required by simplygon.
						VertexBoneIds[InfluenceIndex] = -1;
						VertexBoneWeights[InfluenceIndex] = 0;
					}
				}
				check(TotalInfluence == 255);

				Vertex.Position = GetConversionMatrix().TransformPosition(Vertex.Position);

				//Vertex.Position.Z = -Vertex.Position.Z;
				Positions->SetTuple(VertexIndex, (float*)&Vertex.Position);
				BoneIds->SetTuple(VertexIndex, VertexBoneIds);
				BoneWeights->SetTuple(VertexIndex, VertexBoneWeights);
			}
			FirstVertex = LastVertex;
		}

		// Add per-vertex per-triangle data.
		for (uint32 SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex)
		{
			const FSkelMeshSection& Section = LODModel.Sections[SectionIndex];
			const uint32 FirstIndex = Section.BaseIndex;
			const uint32 LastIndex = FirstIndex + Section.NumTriangles * 3;

			for (uint32 Index = FirstIndex; Index < LastIndex; ++Index)
			{
				uint32 VertexIndex = IndexData.Indices[Index];
				FSoftSkinVertex& Vertex = Vertices[VertexIndex];

				FVector Normal = Vertex.TangentZ;
				Normal = GetConversionMatrix().TransformPosition(Normal);

				FVector Tangent = Vertex.TangentX;
				Tangent = GetConversionMatrix().TransformPosition(Tangent);

				FVector Bitangent = Vertex.TangentY;
				Bitangent = GetConversionMatrix().TransformPosition(Bitangent);


				Indices->SetItem(Index, VertexIndex);
				Normals->SetTuple(Index, (float*)&Normal);
				Tangents->SetTuple(Index, (float*)&Tangent);
				Bitangents->SetTuple(Index, (float*)&Bitangent);

				for (uint32 TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex)
				{
					FVector2D TexCoord = Vertex.UVs[TexCoordIndex];
					TexCoords[TexCoordIndex]->SetTuple(Index, (float*)&TexCoord);
				}

				if (Colors)
				{
					FColor Color = LODModel.ColorVertexBuffer.VertexColor(VertexIndex);
					Colors->SetTuple(Index, (UCHAR*)&Color);
				}
			}
		}

		// Add per-triangle data.
		for (uint32 SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex)
		{
			const FSkelMeshSection& Section = LODModel.Sections[SectionIndex];
			const uint32 FirstTriIndex = Section.BaseIndex / 3;
			const uint32 LastTriIndex = FirstTriIndex + Section.NumTriangles - 1;
			const uint16 MaterialIndex = Section.MaterialIndex;
			for (uint32 TriIndex = FirstTriIndex; TriIndex <= LastTriIndex; ++TriIndex)
			{
				MaterialIndices->SetItem(TriIndex, MaterialIndex);
				check(MaterialIndices->GetItem(TriIndex) == MaterialIndex);
			}
		}

		// Create a new simplygon scene mesh object
		SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();

		// Assign the geometry data to the mesh
		Mesh->SetGeometry(GeometryData);

		// Add Mesh to the scene
		Scene->GetRootNode()->AddChild(Mesh);

		return GeometryData;
	}

	//@third party code BEGIN SIMPLYGON 
	// This is a copy of CreateGeometryFromSkeletalLODModel with additional features for material LOD.
	SimplygonSDK::spGeometryData CreateGeometryFromSkeletalLODModel(
		SimplygonSDK::spScene& Scene,
		const FStaticLODModel& LODModel,
		const TArray<SimplygonSDK::rid>& BoneIDs,
		const FBox2D& TextureBounds,
		const TArray<FVector2D>& InTexCoords)
	{
		TArray<FSoftSkinVertex> Vertices;
		FMultiSizeIndexContainerData IndexData;
		LODModel.GetVertices(Vertices);
		LODModel.MultiSizeIndexContainer.GetIndexBufferData(IndexData);

		const uint32 VertexCount = LODModel.NumVertices;
		const uint32 TexCoordCount = LODModel.NumTexCoords;
		check(TexCoordCount <= MAX_TEXCOORDS);

		uint32 TriCount = 0;
#if WITH_APEX_CLOTHING
		const uint32 SectionCount = (uint32)LODModel.NumNonClothingSections();
#else
		const uint32 SectionCount = LODModel.Sections.Num();
#endif // #if WITH_APEX_CLOTHING
		for (uint32 SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex)
		{
			TriCount += LODModel.Sections[SectionIndex].NumTriangles;
		}

		SimplygonSDK::spGeometryData GeometryData = SDK->CreateGeometryData();
		GeometryData->SetVertexCount(VertexCount);
		GeometryData->SetTriangleCount(TriCount);

		// Per-vertex data.
		GeometryData->AddBoneIds(MAX_TOTAL_INFLUENCES);
		GeometryData->AddBoneWeights(MAX_TOTAL_INFLUENCES);
		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray BoneIds = GeometryData->GetBoneIds();
		SimplygonSDK::spRealArray BoneWeights = GeometryData->GetBoneWeights();

		// Per-corner per-triangle data.
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRealArray TexCoords[MAX_TEXCOORDS];
		for (uint32 TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex)
		{
			GeometryData->AddTexCoords(TexCoordIndex);
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords(TexCoordIndex);
			check(TexCoords[TexCoordIndex]->GetTupleSize() == 2);
		}
		GeometryData->AddNormals();
		GeometryData->AddTangents(0);
		GeometryData->AddBitangents(0);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);

		SimplygonSDK::spUnsignedCharArray Colors;
		if (LODModel.ColorVertexBuffer.GetNumVertices() == VertexCount)
		{
			GeometryData->AddBaseTypeUserTriangleVertexField(SimplygonSDK::TYPES_ID_UCHAR, SIMPLYGON_COLOR_CHANNEL, 4);
			SimplygonSDK::spValueArray ColorValues = GeometryData->GetUserTriangleVertexField(SIMPLYGON_COLOR_CHANNEL);
			check(ColorValues);
			Colors = SimplygonSDK::IUnsignedCharArray::SafeCast(ColorValues);
			check(Colors);
		}

		// Per-triangle data.
		GeometryData->AddMaterialIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();

		// Add per-vertex data. This data needs to be added per-chunk so that we can properly map bones.
#if WITH_APEX_CLOTHING
		const int32 ChunkCount = LODModel.NumNonClothingSections();
#else
		const int32 ChunkCount = LODModel.Chunks.Num();
#endif // #if WITH_APEX_CLOTHING
		uint32 FirstVertex = 0;
		for (int32 ChunkIndex = 0; ChunkIndex < ChunkCount; ++ChunkIndex)
		{
			const FSkelMeshChunk& Chunk = LODModel.Chunks[ChunkIndex];
			const uint32 LastVertex = FirstVertex + (uint32)Chunk.RigidVertices.Num() + (uint32)Chunk.SoftVertices.Num();
			for (uint32 VertexIndex = FirstVertex; VertexIndex < LastVertex; ++VertexIndex)
			{
				FSoftSkinVertex& Vertex = Vertices[VertexIndex];
				SimplygonSDK::rid VertexBoneIds[MAX_TOTAL_INFLUENCES];
				SimplygonSDK::real VertexBoneWeights[MAX_TOTAL_INFLUENCES];

				uint32 TotalInfluence = 0;
				for (uint32 InfluenceIndex = 0; InfluenceIndex < MAX_TOTAL_INFLUENCES; ++InfluenceIndex)
				{
					int32 BoneIndex = Vertex.InfluenceBones[InfluenceIndex];
					const uint8 BoneInfluence = Vertex.InfluenceWeights[InfluenceIndex];
					TotalInfluence += BoneInfluence;

					if (BoneInfluence > 0)
					{
						check(BoneIndex < Chunk.BoneMap.Num());
						uint32 BoneID = BoneIDs[Chunk.BoneMap[BoneIndex]];
						VertexBoneIds[InfluenceIndex] = BoneID;
						VertexBoneWeights[InfluenceIndex] = BoneInfluence / 255.0f;
					}
					else
					{
						//Set BoneID and BoneWeight to -1 and 0 respectively as required by simplygon.
						VertexBoneIds[InfluenceIndex] = -1;
						VertexBoneWeights[InfluenceIndex] = 0;
					}
				}
				check(TotalInfluence == 255);

				Vertex.Position = GetConversionMatrix().TransformPosition(Vertex.Position);

				//Vertex.Position.Z = -Vertex.Position.Z;
				Positions->SetTuple(VertexIndex, (float*)&Vertex.Position);
				BoneIds->SetTuple(VertexIndex, VertexBoneIds);
				BoneWeights->SetTuple(VertexIndex, VertexBoneWeights);
			}
			FirstVertex = LastVertex;
		}

		// Add per-vertex per-triangle data.
		for (uint32 SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex)
		{
			const FSkelMeshSection& Section = LODModel.Sections[SectionIndex];
			const uint32 FirstIndex = Section.BaseIndex;
			const uint32 LastIndex = FirstIndex + Section.NumTriangles * 3;

			for (uint32 Index = FirstIndex; Index < LastIndex; ++Index)
			{
				uint32 VertexIndex = IndexData.Indices[Index];
				FSoftSkinVertex& Vertex = Vertices[VertexIndex];

				FVector Normal = Vertex.TangentZ;
				Normal = GetConversionMatrix().TransformPosition(Normal);

				FVector Tangent = Vertex.TangentX;
				Tangent = GetConversionMatrix().TransformPosition(Tangent);

				FVector Bitangent = Vertex.TangentY;
				Bitangent = GetConversionMatrix().TransformPosition(Bitangent);


				Indices->SetItem(Index, VertexIndex);
				Normals->SetTuple(Index, (float*)&Normal);
				Tangents->SetTuple(Index, (float*)&Tangent);
				Bitangents->SetTuple(Index, (float*)&Bitangent);

				if (Colors)
				{
					FColor Color = LODModel.ColorVertexBuffer.VertexColor(VertexIndex);
					Colors->SetTuple(Index, (UCHAR*)&Color);
				}
			}
		}

		// Add texture coordinates.
		for (uint32 TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex)
		{
			for (uint32 SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex)
			{
				const FSkelMeshSection& Section = LODModel.Sections[SectionIndex];
				const uint32 FirstIndex = Section.BaseIndex;
				const uint32 LastIndex = FirstIndex + Section.NumTriangles * 3;

				// Compute texture bounds for current material.
				float MinU = 0, ScaleU = 1;
				float MinV = 0, ScaleV = 1;
				if (TextureBounds.bIsValid && TexCoordIndex == 0 && InTexCoords.Num() == 0)
				{
					if (TextureBounds.GetArea() > 0)
					{
						MinU = TextureBounds.Min.X;
						MinV = TextureBounds.Min.Y;
						ScaleU = 1.0f / (TextureBounds.Max.X - TextureBounds.Min.X);
						ScaleV = 1.0f / (TextureBounds.Max.Y - TextureBounds.Min.Y);
					}
				}

				for (uint32 Index = FirstIndex; Index < LastIndex; ++Index)
				{
					uint32 VertexIndex = IndexData.Indices[Index];
					FSoftSkinVertex& Vertex = Vertices[VertexIndex];

					bool bUseExternalTexCoords = (TexCoordIndex == 0 && InTexCoords.Num() > 0);
					const FVector2D& TexCoord = bUseExternalTexCoords ? InTexCoords[Index] : Vertex.UVs[TexCoordIndex];
					float UV[2];
					UV[0] = (TexCoord.X - MinU) * ScaleU;
					UV[1] = (TexCoord.Y - MinV) * ScaleV;
					TexCoords[TexCoordIndex]->SetTuple(Index, UV);
				}
			}
		}

		// Add per-triangle data.
		for (uint32 SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex)
		{
			const FSkelMeshSection& Section = LODModel.Sections[SectionIndex];
			const uint32 FirstTriIndex = Section.BaseIndex / 3;
			const uint32 LastTriIndex = FirstTriIndex + Section.NumTriangles - 1;
			const uint16 MaterialIndex = Section.MaterialIndex;
			for (uint32 TriIndex = FirstTriIndex; TriIndex <= LastTriIndex; ++TriIndex)
			{
				MaterialIndices->SetItem(TriIndex, MaterialIndex);
				check(MaterialIndices->GetItem(TriIndex) == MaterialIndex);
			}
		}

		// Create a new simplygon scene mesh object
		SimplygonSDK::spSceneMesh Mesh = SDK->CreateSceneMesh();

		// Assign the geometry data to the mesh
		Mesh->SetGeometry(GeometryData);

		// Add Mesh to the scene
		Scene->GetRootNode()->AddChild(Mesh);

		return GeometryData;
	}

	void AddMorphTargetsToGeometry(const USkeletalMesh* SkeletalMesh, int32 BaseLODModel, SimplygonSDK::spGeometryData& GeometryData)
	{
		if (SkeletalMesh->MorphTargets.Num() == 0)
		{
			return;
		}

		// Obtain vertices of original LODModel
		FSkeletalMeshResource* SkeletalMeshResource = SkeletalMesh->GetImportedResource();
		const FStaticLODModel& SrcModel = SkeletalMeshResource->LODModels[BaseLODModel];
		int32 NumVertices = SrcModel.NumVertices;
		FMultiSizeIndexContainerData IndexData;
		SrcModel.MultiSizeIndexContainer.GetIndexBufferData(IndexData);
		int32 NumCorners = IndexData.Indices.Num();

		// Compute maximal morph distance for each vertex
		TArray<float> MaxMorphWeight;
		MaxMorphWeight.AddZeroed(NumVertices);
		for (int32 MorphIndex = 0; MorphIndex < SkeletalMesh->MorphTargets.Num(); MorphIndex++)
		{
			UMorphTarget* MorphTarget = SkeletalMesh->MorphTargets[MorphIndex];
			if (MorphTarget)
			{
				int32 NumDeltas;
				const FVertexAnimDelta* Deltas = MorphTarget->GetDeltasAtTime(0.0f, BaseLODModel, NULL, NumDeltas);

				for (int32 MorphVertIdx = 0; MorphVertIdx < NumDeltas; MorphVertIdx++)
				{
					const FVertexAnimDelta& MorphVertex = Deltas[MorphVertIdx];
					float Distance = MorphVertex.PositionDelta.Size();
					int32 WedgeIndex = MorphVertex.SourceIdx;
					if (Distance > MaxMorphWeight[WedgeIndex])
					{
						MaxMorphWeight[WedgeIndex] = Distance;
					}
				}
			}
		}

		// Add vertex weights taking into account morph data
		GeometryData->AddVertexWeighting();
		SimplygonSDK::spRealArray VertexWeights = GeometryData->GetVertexWeighting();
		for (int32 Index = 0; Index < NumVertices; Index++)
		{
			// Add vertex weight. 1.0 is default (normal) weight.
			VertexWeights->SetItem(Index, 1.0f + MaxMorphWeight[Index]);
		}

		for (int32 MorphIndex = 0; MorphIndex < SkeletalMesh->MorphTargets.Num(); MorphIndex++)
		{
			UMorphTarget* MorphTarget = SkeletalMesh->MorphTargets[MorphIndex];
			if (MorphTarget)
			{
				// Get morph geometry
				int32 NumDeltas;
				const FVertexAnimDelta* Deltas = MorphTarget->GetDeltasAtTime(0.0f, BaseLODModel, NULL, NumDeltas);

				// Add vertex streams to GeometryData
				ANSICHAR FieldName1[64];
				ANSICHAR FieldName2[64];
				FCStringAnsi::Sprintf(FieldName1, "MorphVertexField%d", MorphIndex);
				FCStringAnsi::Sprintf(FieldName2, "MorphNormalField%d", MorphIndex);
				SimplygonSDK::spRealArray Field1 = SimplygonSDK::Cast<SimplygonSDK::IRealArray>(GeometryData->AddBaseTypeUserCornerField(SimplygonSDK::TYPES_ID_REAL, FieldName1, 3));
				SimplygonSDK::spRealArray Field2 = SimplygonSDK::Cast<SimplygonSDK::IRealArray>(GeometryData->AddBaseTypeUserCornerField(SimplygonSDK::TYPES_ID_REAL, FieldName2, 3));
				Field1->SetTupleCount(NumCorners);
				Field2->SetTupleCount(NumCorners);

				// Prepare wedge to morph vertex map for fast look up
				TArray<int32> WedgeToMorphVert;
				WedgeToMorphVert.AddUninitialized(NumVertices);
				for (int32 Index = 0; Index < NumVertices; Index++)
				{
					WedgeToMorphVert[Index] = -1;
				}
				for (int32 MorphVertIdx = 0; MorphVertIdx < NumDeltas; MorphVertIdx++)
				{
					const FVertexAnimDelta& MorphVertex = Deltas[MorphVertIdx];
					WedgeToMorphVert[MorphVertex.SourceIdx] = MorphVertIdx;
				}

				// FVertexAnimDelta is sparse array structure holding information about vertices which are
				// changed by morph. Remap corner index -> wedge index -> morph index.
				for (int32 Index = 0; Index < NumCorners; Index++)
				{
					int32 WedgeIndex = IndexData.Indices[Index];
					int32 MorphVertIdx = WedgeToMorphVert[WedgeIndex];
					if (MorphVertIdx >= 0)
					{
						const FVertexAnimDelta& MorphVertex = Deltas[MorphVertIdx];
						check(MorphVertex.SourceIdx == WedgeIndex);

						// Verify vertex index, just in case
						if (MorphVertex.SourceIdx < (uint32)NumVertices)
						{
							// Store delta information into custom fields
							Field1->SetTuple(Index, (float*)&MorphVertex.PositionDelta);
							Field2->SetTuple(Index, (float*)&MorphVertex.TangentZDelta);
						}
					}
				}
			}
		}
	}

	void GetMorphTargetsFromGeometry(USkeletalMesh* SkeletalMesh, int32 LODIndex, const uint32 InLODModelVertexCount, SimplygonSDK::spGeometryData& GeometryData, const TArray<int32>& SourceWedgeMap)
	{
		// Reference: UMorphTarget::CreateMorphMeshStreams()
		for (int32 MorphIndex = 0; MorphIndex < SkeletalMesh->MorphTargets.Num(); MorphIndex++)
		{
			UMorphTarget* MorphTarget = SkeletalMesh->MorphTargets[MorphIndex];
			if (MorphTarget)
			{
				// Get LODModel to modify
				/*FSkeletalMeshResource* SkeletalMeshResource = SkeletalMesh->GetImportedResource();
				const FStaticLODModel& LODModel = SkeletalMeshResource->LODModels[LODIndex];
				check(LODModel.MeshToImportVertexMap.Num());
				int32 NumVertices = LODModel.NumVertices;*/
				int32 NumVertices = InLODModelVertexCount;

				// create the LOD entry if it doesn't already exist
				if (LODIndex == MorphTarget->MorphLODModels.Num())
				{
					new(MorphTarget->MorphLODModels) FMorphTargetLODModel();
				}

				// morph mesh data to modify
				FMorphTargetLODModel& MorphModel = MorphTarget->MorphLODModels[LODIndex];

				// set the original number of vertices
				MorphModel.NumBaseMeshVerts = NumVertices;

				// empty morph mesh vertices first
				MorphModel.Vertices.Empty();

				// Get vertex streams from GeometryData
				ANSICHAR FieldName1[64];
				ANSICHAR FieldName2[64];
				FCStringAnsi::Sprintf(FieldName1, "MorphVertexField%d", MorphIndex);
				FCStringAnsi::Sprintf(FieldName2, "MorphNormalField%d", MorphIndex);
				SimplygonSDK::spRealArray Field1 = SimplygonSDK::Cast<SimplygonSDK::IRealArray>(GeometryData->GetUserCornerField(FieldName1));
				SimplygonSDK::spRealArray Field2 = SimplygonSDK::Cast<SimplygonSDK::IRealArray>(GeometryData->GetUserCornerField(FieldName2));
				check(!Field1.IsNull() && !Field2.IsNull());

				// Read morph data from geometry. Note:	we're iterating vertices in glowing order, so
				// produced morph vertex data is already sorted.
				SimplygonSDK::spRealData sgPositionData = SDK->CreateRealData();
				SimplygonSDK::spRealData sgNormalDeltaData = SDK->CreateRealData();
				for (int32 WedgeIndex = 0; WedgeIndex < NumVertices; WedgeIndex++)
				{
					int32 OriginalCornerIndex = SourceWedgeMap[WedgeIndex];
					FVector PositionDelta, NormalDeltaZ;
					//Field1->GetTuple(OriginalCornerIndex, (float*)&PositionDelta);
					//Field2->GetTuple(OriginalCornerIndex, (float*)&NormalDeltaZ);

					//Position delta
					Field1->GetTuple(OriginalCornerIndex, sgPositionData);
					SimplygonSDK::real* sgPositionDelta = sgPositionData->GetData();
					PositionDelta = FVector(sgPositionDelta[0], sgPositionDelta[1], sgPositionDelta[2]);

					//Normal DeltaZ
					Field2->GetTuple(OriginalCornerIndex, sgNormalDeltaData);
					SimplygonSDK::real* sgNormalDeltaZ = sgNormalDeltaData->GetData();
					NormalDeltaZ = FVector(sgNormalDeltaZ[0], sgNormalDeltaZ[1], sgNormalDeltaZ[2]);

					// check if position actually changed much
					if (PositionDelta.Size() > THRESH_POINTS_ARE_NEAR || NormalDeltaZ.Size() > 0.1f)
					{
						// create a new entry
						FVertexAnimDelta NewVertex;
						// position delta
						NewVertex.PositionDelta = PositionDelta;
						// normal delta
						NewVertex.TangentZDelta = NormalDeltaZ;
						// index of base mesh vert this entry is to modify
						NewVertex.SourceIdx = WedgeIndex;

						// add it to the list of changed verts
						MorphModel.Vertices.Add(NewVertex);
					}
				}
			}
		}
	}
	//@third party code END SIMPLYGON 

	/**
	* Holds data needed to create skeletal mesh skinning streams.
	*/
	struct FSkeletalMeshData
	{
		TArray<FVertInfluence> Influences;
		TArray<FMeshWedge> Wedges;
		TArray<FMeshFace> Faces;
		TArray<FVector> Points;
		uint32 TexCoordCount;
	};

	/**
	* Extracts mesh data from the Simplygon geometry representation in to a set of data usable by skeletal meshes.
	* @param GeometryData - the Simplygon geometry.
	* @param MeshData - the skeletal mesh output data.
	*/
	void ExtractSkeletalDataFromGeometry(const SimplygonSDK::spGeometryData& GeometryData, FSkeletalMeshData& MeshData)
	{
		TArray<FVector> PointNormals;
		TArray<uint32> PointList;
		TArray<uint32> PointInfluenceMap;

		check(GeometryData);

		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		SimplygonSDK::spValueArray VertexColorValues = GeometryData->GetUserTriangleVertexField(SIMPLYGON_COLOR_CHANNEL);
		SimplygonSDK::spUnsignedCharArray VertexColors = SimplygonSDK::IUnsignedCharArray::SafeCast(VertexColorValues);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);
		SimplygonSDK::spRidArray BoneIds = GeometryData->GetBoneIds();
		SimplygonSDK::spRealArray BoneWeights = GeometryData->GetBoneWeights();
		SimplygonSDK::spRealArray TexCoords[MAX_TEXCOORDS];
		uint32 TexCoordCount = 0;
		for (uint32 TexCoordIndex = 0; TexCoordIndex < MAX_TEXCOORDS; ++TexCoordIndex)
		{
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords(TexCoordIndex);
			if (TexCoords[TexCoordIndex] == NULL)
			{
				break;
			}
			TexCoordCount++;
		}
		MeshData.TexCoordCount = TexCoordCount;

		check(Positions);
		check(Indices);
		//@third party code BEGIN SIMPLYGON 
		//		check( MaterialIndices );
		//@third party code END SIMPLYGON 
		check(Normals);
		check(Tangents);
		check(Bitangents);
		check(BoneIds);
		check(BoneWeights);

		const bool bHaveColors = (VertexColors != NULL);
		const uint32 VertexCount = GeometryData->GetVertexCount();
		const uint32 TriCount = GeometryData->GetTriangleCount();

		// Initialize the lists of points, wedges, and faces.
		MeshData.Points.AddZeroed(VertexCount);
		PointNormals.AddZeroed(VertexCount);
		PointList.Reserve(VertexCount);
		PointInfluenceMap.Reserve(VertexCount);
		for (uint32 PointIndex = 0; PointIndex < VertexCount; ++PointIndex)
		{
			PointList.Add(INDEX_NONE);
			PointInfluenceMap.Add(INDEX_NONE);
		}
		MeshData.Wedges.AddZeroed(TriCount * 3);
		MeshData.Faces.AddZeroed(TriCount);

		//The number of influences may have changed if we have specified a max number of bones per vertex.
		uint32 NumOfInfluences = FMath::Min<uint32>(BoneIds->GetTupleSize(), MAX_TOTAL_INFLUENCES);

		SimplygonSDK::spRealData sgPositionData = SDK->CreateRealData();
		SimplygonSDK::spRidData sgBoneIdsData = SDK->CreateRidData();
		SimplygonSDK::spRealData sgBoneWeightsData = SDK->CreateRealData();
		SimplygonSDK::spRealData sgTangentData = SDK->CreateRealData();
		SimplygonSDK::spRealData sgTexCoordData = SDK->CreateRealData();
		SimplygonSDK::spUnsignedCharData sgVertexColorData = SDK->CreateUnsignedCharData();

		//@third party code BEGIN SIMPLYGON
		check(BoneWeights->GetTupleCount() == VertexCount);
		//@third party code END SIMPLYGON

		// Per-vertex data.
		for (uint32 VertexIndex = 0; VertexIndex < VertexCount; ++VertexIndex)
		{
			//@third party code BEGIN SIMPLYGON
			//Left changed lines commented below, changes where done due to SimplygonSDK 7.0

			FVector& Point = MeshData.Points[VertexIndex];
			//SimplygonSDK::rid VertexBoneIds[MAX_TOTAL_INFLUENCES];
			//SimplygonSDK::real VertexBoneWeights[MAX_TOTAL_INFLUENCES];

			//Positions->GetTuple( VertexIndex, (float*)&Point );
			Positions->GetTuple(VertexIndex, sgPositionData);
			SimplygonSDK::real* sgPosition = sgPositionData->GetData();
			Point = FVector(sgPosition[0], sgPosition[1], sgPosition[2]);


			//BoneIds->GetTuple( VertexIndex, VertexBoneIds );
			BoneIds->GetTuple(VertexIndex, sgBoneIdsData);
			SimplygonSDK::rid* sgBoneId = sgBoneIdsData->GetData();


			//BoneWeights->GetTuple( VertexIndex, VertexBoneWeights );
			BoneWeights->GetTuple(VertexIndex, sgBoneWeightsData);
			SimplygonSDK::real* sgBoneWeights = sgBoneWeightsData->GetData();

			PointInfluenceMap[VertexIndex] = (uint32)MeshData.Influences.Num();
			for (uint32 InfluenceIndex = 0; InfluenceIndex < NumOfInfluences; ++InfluenceIndex)
			{
				//const uint16 BoneIndex = sgBoneId[InfluenceIndex];
				const int32 BoneIndex = sgBoneId[InfluenceIndex];
				const float BoneWeight = sgBoneWeights[InfluenceIndex];
				if (BoneIndex >= 0 && BoneWeight > 0.0f)
				{
					FVertInfluence* VertInfluence = new(MeshData.Influences) FVertInfluence;
					VertInfluence->BoneIndex = BoneIndex;
					VertInfluence->Weight = BoneWeight;
					VertInfluence->VertIndex = VertexIndex;
				}
			}
			//@third party code END SIMPLYGON
		}

		// Per-triangle and per-corner data.
		for (uint32 TriIndex = 0; TriIndex < TriCount; ++TriIndex)
		{
			// Per-triangle data.
			FMeshFace& Face = MeshData.Faces[TriIndex];
			//@third party code BEGIN SIMPLYGON 
			Face.MeshMaterialIndex = MaterialIndices ? MaterialIndices->GetItem(TriIndex) : 0;
			//@third party code END SIMPLYGON 

			// Per-corner data.
			for (uint32 CornerIndex = 0; CornerIndex < 3; ++CornerIndex)
			{
				const uint32 WedgeIndex = TriIndex * 3 + CornerIndex;
				const uint32 BasePointIndex = (uint32)Indices->GetItem(WedgeIndex);
				uint32 PointIndex = BasePointIndex;

				check(BasePointIndex < (uint32)PointList.Num());

				// Duplicate points where needed to create hard edges.
				FVector WedgeNormal;
				//Normals->GetTuple( WedgeIndex, (float*)&WedgeNormal );
				Normals->GetTuple(WedgeIndex, sgTangentData);
				SimplygonSDK::real* sgNormal = sgTangentData->GetData();
				WedgeNormal = FVector(sgNormal[0], sgNormal[1], sgNormal[2]);
				WedgeNormal.Normalize();

				//@third party code BEGIN SIMPLYGON
				FVector WedgeTangent, WedgeBitangent;
				//Tangents->GetTuple( WedgeIndex, (float*)&WedgeTangent );
				Tangents->GetTuple(WedgeIndex, sgTangentData);
				SimplygonSDK::real* sgTangent = sgTangentData->GetData();
				WedgeTangent = FVector(sgTangent[0], sgTangent[1], sgTangent[2]);

				//Bitangents->GetTuple( WedgeIndex, (float*)&WedgeBitangent );
				Bitangents->GetTuple(WedgeIndex, sgTangentData);
				SimplygonSDK::real* sgBitangent = sgTangentData->GetData();
				WedgeBitangent = FVector(sgBitangent[0], sgBitangent[1], sgBitangent[2]);

				Face.TangentX[CornerIndex] = WedgeTangent;
				Face.TangentY[CornerIndex] = WedgeBitangent;
				Face.TangentZ[CornerIndex] = WedgeNormal;
				//@third party code END SIMPLYGON

				FVector PointNormal = PointNormals[PointIndex];
				if (PointNormal.SizeSquared() < KINDA_SMALL_NUMBER)
				{
					PointNormals[PointIndex] = WedgeNormal;
				}
				else
				{
					while ((PointNormal | WedgeNormal) - 1.0f < -KINDA_SMALL_NUMBER)
					{
						PointIndex = PointList[PointIndex];
						if (PointIndex == INDEX_NONE)
						{
							break;
						}
						check(PointIndex < (uint32)PointList.Num());
						PointNormal = PointNormals[PointIndex];
					}

					if (PointIndex == INDEX_NONE)
					{
						FVector Point = MeshData.Points[BasePointIndex];
						PointIndex = MeshData.Points.Add(Point);
						check(PointIndex == (uint32)PointList.Num());
						check(PointIndex == (uint32)PointInfluenceMap.Num());
						check(PointIndex == (uint32)PointNormals.Num());
						PointNormals.Add(WedgeNormal);
						uint32 NextPointIndex = PointList[BasePointIndex];
						check(NextPointIndex < (uint32)PointList.Num() || NextPointIndex == INDEX_NONE);
						PointList[BasePointIndex] = PointIndex;
						PointList.Add(NextPointIndex);
						PointInfluenceMap.Add((uint32)MeshData.Influences.Num());

						int32 InfluenceIndex = PointInfluenceMap[BasePointIndex];
						while (MeshData.Influences[InfluenceIndex].VertIndex == BasePointIndex)
						{
							FVertInfluence* NewVertInfluence = new(MeshData.Influences) FVertInfluence;
							NewVertInfluence->BoneIndex = MeshData.Influences[InfluenceIndex].BoneIndex;
							NewVertInfluence->Weight = MeshData.Influences[InfluenceIndex].Weight;
							NewVertInfluence->VertIndex = PointIndex;
							InfluenceIndex++;
						}

						check(PointNormals.Num() == MeshData.Points.Num());
						check(PointList.Num() == MeshData.Points.Num());
						check(PointInfluenceMap.Num() == MeshData.Points.Num());
					}
				}

				check(PointIndex != INDEX_NONE);
				check((MeshData.Points[PointIndex] - MeshData.Points[BasePointIndex]).SizeSquared() == 0.0f);

				FMeshWedge& Wedge = MeshData.Wedges[WedgeIndex];
				Wedge.iVertex = PointIndex;
				for (uint32 TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex)
				{
					//TexCoords[TexCoordIndex]->GetTuple( WedgeIndex, (float*)&Wedge.UVs[TexCoordIndex] );
					TexCoords[TexCoordIndex]->GetTuple(WedgeIndex, sgTexCoordData);
					SimplygonSDK::real* sgTexCoord = sgTexCoordData->GetData();
					Wedge.UVs[TexCoordIndex] = FVector2D(sgTexCoordData[0], sgTexCoordData[1]);
				}

				if (bHaveColors)
				{
					//VertexColors->GetTuple( WedgeIndex, (uint8 *)&Wedge.Color );
					VertexColors->GetTuple(WedgeIndex, sgVertexColorData);
					uint8* sgColors = sgVertexColorData->GetData();
					Wedge.Color = FColor(sgColors[0], sgColors[1], sgColors[2], sgColors[3]);
				}
				else
				{
					Wedge.Color = FColor(255, 255, 255, 255);
				}

				Face.iWedge[CornerIndex] = WedgeIndex;
			}
		}
	}

	/**
	* Creates a skeletal mesh LOD model from the Simplygon geometry representation.
	* @param GeometryData - the Simplygon geometry representation from which to create a skeletal mesh LOD.
	* @param SkeletalMesh - the skeletal mesh in to which the LOD model will be added.
	* @param NewModel - the LOD model in to which the geometry will be stored.
	*/
	void CreateSkeletalLODModelFromGeometry(
		const SimplygonSDK::spGeometryData& GeometryData,
		const FReferenceSkeleton& RefSkeleton,
		FStaticLODModel* NewModel,
		//@third party code BEGIN SIMPLYGON
		TArray<int32>* OutSourceWedgeMap = nullptr
		//@third party code BEGIN SIMPLYGON
		)
	{
		check(GeometryData);

		FSkeletalMeshData MeshData;
		ExtractSkeletalDataFromGeometry(GeometryData, MeshData);

		//@third party code BEGIN SIMPLYGON 
		TArray<FVector>& Vertices = MeshData.Points;
		for (int32 VertexIndex = 0; VertexIndex < MeshData.Points.Num(); ++VertexIndex)
		{
			Vertices[VertexIndex] = GetConversionMatrix().TransformPosition(Vertices[VertexIndex]);
		}

		for (int32 FaceIndex = 0; FaceIndex < MeshData.Faces.Num(); ++FaceIndex)
		{
			FMeshFace& Face = MeshData.Faces[FaceIndex];
			for (int32 CornerIndex = 0; CornerIndex < 3; ++CornerIndex)
			{
				Face.TangentX[CornerIndex] = GetConversionMatrix().TransformPosition(Face.TangentX[CornerIndex]);
				Face.TangentY[CornerIndex] = GetConversionMatrix().TransformPosition(Face.TangentY[CornerIndex]);
				Face.TangentZ[CornerIndex] = GetConversionMatrix().TransformPosition(Face.TangentZ[CornerIndex]);
			}


		}
		//@third party code END SIMPLYGON 


		// Create dummy map of 'point to original'
		TArray<int32> DummyMap;
		DummyMap.AddUninitialized(MeshData.Points.Num());
		for (int32 PointIdx = 0; PointIdx<MeshData.Points.Num(); PointIdx++)
		{
			DummyMap[PointIdx] = PointIdx;
		}

		IMeshUtilities& MeshUtilities = FModuleManager::Get().LoadModuleChecked<IMeshUtilities>("MeshUtilities");
		// Create skinning streams for NewModel.
		MeshUtilities.BuildSkeletalMesh(
			*NewModel,
			RefSkeleton,
			MeshData.Influences,
			MeshData.Wedges,
			MeshData.Faces,
			MeshData.Points,
			DummyMap,
			//@third party code BEGIN SIMPLYGON 
			false,
			false,
			false,
			nullptr,
			nullptr,
			OutSourceWedgeMap
			//@third party code END SIMPLYGON 
			);

		// Set texture coordinate count on the new model.
		NewModel->NumTexCoords = MeshData.TexCoordCount;
		NewModel->Size = 0;
	}

	/**
	* Sets reduction settings for Simplygon.
	* @param Settings - The skeletal mesh optimization settings.
	* @param ReductionSettings - The reduction settings to set for Simplygon.
	*/
	void SetReductionSettings(const FSkeletalMeshOptimizationSettings& Settings, float BoundsRadius, int32 SourceTriCount, SimplygonSDK::spReductionSettings ReductionSettings)
	{
		// Compute max deviation from quality.
		float MaxDeviation = Settings.MaxDeviationPercentage > 0.0f ? Settings.MaxDeviationPercentage * BoundsRadius : SimplygonSDK::REAL_MAX;
		// Set the reduction ratio such that at least 1 triangle or 5% of the original triangles remain, whichever is larger.
		float MinReductionRatio = FMath::Max<float>(1.0f / SourceTriCount, 0.05f);
		float MaxReductionRatio = (Settings.MaxDeviationPercentage > 0.0f && Settings.NumOfTrianglesPercentage == 1.0f) ? MinReductionRatio : 1.0f;
		float ReductionRatio = FMath::Clamp(Settings.NumOfTrianglesPercentage, MinReductionRatio, MaxReductionRatio);

		const float ImportanceTable[] =
		{
			0.0f,	// OFF
			0.125f,	// Lowest
			0.35f,	// Low,
			1.0f,	// Normal
			2.8f,	// High
			8.0f,	// Highest
		};

		static_assert(ARRAY_COUNT(ImportanceTable) == SMOI_MAX, "Bad importance table size.");
		check(Settings.SilhouetteImportance < SMOI_MAX);
		check(Settings.TextureImportance < SMOI_MAX);
		check(Settings.ShadingImportance < SMOI_MAX);
		check(Settings.SkinningImportance < SMOI_MAX);

		ReductionSettings->SetStopCondition(SimplygonSDK::SG_STOPCONDITION_ANY);
		ReductionSettings->SetReductionTargets(SimplygonSDK::SG_REDUCTIONTARGET_TRIANGLERATIO | SimplygonSDK::SG_REDUCTIONTARGET_MAXDEVIATION);
		ReductionSettings->SetMaxDeviation(MaxDeviation);
		ReductionSettings->SetTriangleRatio(ReductionRatio);
		ReductionSettings->SetGeometryImportance(ImportanceTable[Settings.SilhouetteImportance]);
		ReductionSettings->SetTextureImportance(ImportanceTable[Settings.TextureImportance]);
		ReductionSettings->SetMaterialImportance(ImportanceTable[Settings.TextureImportance]);
		ReductionSettings->SetShadingImportance(ImportanceTable[Settings.ShadingImportance]);
		ReductionSettings->SetSkinningImportance(ImportanceTable[Settings.SkinningImportance]);

		ReductionSettings->SetDataCreationPreferences(2); //2 = reposition vertices enabled
		ReductionSettings->SetGenerateGeomorphData(true);

	}

	//@third party code BEGIN SIMPLYGON 
	void SetRemeshingSettings(const FSimplygonRemeshingSettings& Settings, SimplygonSDK::spRemeshingProcessor RemeshingProcessor)
	{
		SimplygonSDK::spRemeshingSettings RemeshingSettings = RemeshingProcessor->GetRemeshingSettings();
		RemeshingSettings->SetOnScreenSize(Settings.ScreenSize);
		RemeshingSettings->SetMergeDistance(Settings.MergeDistance);
		//RemeshingSettings->SetUseGroundPlane(Settings.bUseClippingPlane);
		//RemeshingSettings->SetGroundPlaneAxisIndex(Settings.AxisIndex); // 0:X-Axis, 1:Y-Axis, 2:Z-Axis
		//RemeshingSettings->SetGroundPlaneLevel(Settings.ClippingLevel);
		//RemeshingSettings->SetGroundPlaneNegativeHalfspace(Settings.bPlaneNegativeHalfspace);
		RemeshingSettings->SetTransferNormals(false);
		RemeshingSettings->SetMergeDistance(Settings.MergeDistance);
		RemeshingSettings->SetHardEdgeAngleInRadians(FMath::DegreesToRadians(Settings.HardAngleThreshold));
	}
	//@third party code END SIMPLYGON 

	/**
	* Sets vertex normal settings for Simplygon.
	* @param Settings - The skeletal mesh optimization settings.
	* @param NormalSettings - The normal settings to set for Simplygon.
	*/
	void SetNormalSettings(const FSkeletalMeshOptimizationSettings& Settings, SimplygonSDK::spNormalCalculationSettings NormalSettings)
	{
		NormalSettings->SetReplaceNormals(Settings.bRecalcNormals);
		NormalSettings->SetScaleByArea(false);
		NormalSettings->SetScaleByAngle(false);
		NormalSettings->SetHardEdgeAngleInRadians(FMath::DegreesToRadians(Settings.NormalsThreshold));
	}

	/**
	* Sets Bone Lod settings for Simplygon.
	* @param Settings - The skeletal mesh optimization settings.
	* @param BoneSettings - The Bone LOD to set for Simplygon.
	*/
	void SetBoneSettings(const FSkeletalMeshOptimizationSettings& Settings, SimplygonSDK::spBoneSettings BoneSettings)
	{
		BoneSettings->SetBoneReductionTargets(SimplygonSDK::SG_BONEREDUCTIONTARGET_BONERATIO);
		BoneSettings->SetBoneRatio(Settings.BoneReductionRatio);
		BoneSettings->SetMaxBonePerVertex(Settings.MaxBonesPerVertex);
		//@third party code BEGIN SIMPLYGON
		BoneSettings->SetLimitBonesPerVertex(true);
		BoneSettings->SetUseBoneReducer(true);
		//BoneSettings->SetRemoveUnusedBones( Settings.)
		//@third party code END SIMPLYGON

	}

	/**
	* Calculates the view distance that a mesh should be displayed at.
	* @param MaxDeviation - The maximum surface-deviation between the reduced geometry and the original. This value should be acquired from Simplygon
	* @returns The calculated view distance
	*/
	float CalculateViewDistance(float MaxDeviation)
	{
		// We want to solve for the depth in world space given the screen space distance between two pixels
		//
		// Assumptions:
		//   1. There is no scaling in the view matrix.
		//   2. The horizontal FOV is 90 degrees.
		//   3. The backbuffer is 1920x1080.
		//
		// If we project two points at (X,Y,Z) and (X',Y,Z) from view space, we get their screen
		// space positions: (X/Z, Y'/Z) and (X'/Z, Y'/Z) where Y' = Y * AspectRatio.
		//
		// The distance in screen space is then sqrt( (X'-X)^2/Z^2 + (Y'-Y')^2/Z^2 )
		// or (X'-X)/Z. This is in clip space, so PixelDist = 1280 * 0.5 * (X'-X)/Z.
		//
		// Solving for Z: ViewDist = (X'-X * 640) / PixelDist

		const float ViewDistance = (MaxDeviation * 960.0f);
		return ViewDistance;
	}

	/**
	* ProxyLOD Related Methods
	*/
	void SetMaterialChannelData(
		const TArray<FColor>& InSamples,
		FIntPoint InTextureSize,
		SimplygonSDK::spMaterial& InSGMaterial,
		const char* SGMaterialChannelName)
	{
		//@third party code BEGIN SIMPLYGON
		if (InSamples.Num() >= 1)
		{
			int32 NumTexels = InTextureSize.X * InTextureSize.Y;
			if (InSamples.Num() == 1)
			{
				NumTexels = 1;
				InTextureSize = FIntPoint(1, 1);
			}
			//@third party code END SIMPLYGON
			SimplygonSDK::spImageData ImageData = SDK->CreateImageData();
			ImageData->AddColors(SimplygonSDK::TYPES_ID_UCHAR, SimplygonSDK::SG_IMAGEDATA_FORMAT_RGBA);
			ImageData->Set2DSize(InTextureSize.X, InTextureSize.Y);
			SimplygonSDK::spUnsignedCharArray ImageColors = SimplygonSDK::SafeCast<SimplygonSDK::IUnsignedCharArray>(ImageData->GetColors());

			//Set the texture data to simplygon color data texel per texel
			ImageColors->SetTupleCount(NumTexels);
			for (int32 TexelIndex = 0; TexelIndex < NumTexels; TexelIndex++)
			{
				// BGRA -> RGBA
				uint8 Texel[4];
				Texel[0] = InSamples[TexelIndex].R;
				Texel[1] = InSamples[TexelIndex].G;
				Texel[2] = InSamples[TexelIndex].B;

				if (SGMaterialChannelName == SimplygonSDK::SG_MATERIAL_CHANNEL_DIFFUSE ||
					SGMaterialChannelName == SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR)
				{
					Texel[3] = InSamples[TexelIndex].A;
				}
				else
				{
					Texel[3] = FColor::White.A;
				}

				ImageColors->SetTuple(TexelIndex, Texel);
			}
			InSGMaterial->SetColor(SGMaterialChannelName, 1.0, 1.0, 1.0, 1.0);
			InSGMaterial->SetLayeredTextureImage(SGMaterialChannelName, 0, ImageData);
			InSGMaterial->SetLayeredTextureLevel(SGMaterialChannelName, 0, 0);


		}
		/*		else if (InSamples.Num() == 1) // this code is disabled because it will produce sRGB result for linear color value; Num() == 1 is enclosed in previous "if"
		{
		// handle uniform value
		InSGMaterial->SetColorRGB(SGMaterialChannelName, InSamples[0].R / 255.0f, InSamples[0].G / 255.0f, InSamples[0].B / 255.0f);
		} */
		else
		{
			InSGMaterial->SetColorRGB(SGMaterialChannelName, 1.0f, 1.0f, 1.0f);
		}
	}

	//Material conversions
	bool CreateSGMaterialFromFlattenMaterial(
		const TArray<FFlattenMaterial>& InputMaterials,
		SimplygonSDK::spMaterialTable& OutSGMaterialTable,
		FMaterialCastingProperties& OutCastProperties)
	{
		if (InputMaterials.Num() == 0)
		{
			//If there are no materials, feed Simplygon with a default material instead.
			UE_LOG(LogSimplygon, Log, TEXT("Input meshes do not contain any materials. A proxy without material will be generated."));
			return false;
		}

		for (int32 MaterialIndex = 0; MaterialIndex < InputMaterials.Num(); MaterialIndex++)
		{
			SimplygonSDK::spMaterial SGMaterial = SDK->CreateMaterial();
			const FFlattenMaterial& FlattenMaterial = InputMaterials[MaterialIndex];

			//Create UE4 Channels
			//Simplygon 5.5 has three new channels already present called base color metallic roughness
			//To conform with older simplygon versions:
			if (!SGMaterial->HasUserChannel(SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR))
				SGMaterial->AddUserChannel(SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR);

			if (!SGMaterial->HasUserChannel(SimplygonSDK::SG_MATERIAL_CHANNEL_METALLIC))
				SGMaterial->AddUserChannel(SimplygonSDK::SG_MATERIAL_CHANNEL_METALLIC);

			if (!SGMaterial->HasUserChannel(SimplygonSDK::SG_MATERIAL_CHANNEL_ROUGHNESS))
				SGMaterial->AddUserChannel(SimplygonSDK::SG_MATERIAL_CHANNEL_ROUGHNESS);

			// We actually use these channels for metallic, roughness and specular
			if (!SGMaterial->HasUserChannel(USER_MATERIAL_CHANNEL_METALLIC))
				SGMaterial->AddUserChannel(USER_MATERIAL_CHANNEL_METALLIC);

			if (!SGMaterial->HasUserChannel(USER_MATERIAL_CHANNEL_ROUGHNESS))
				SGMaterial->AddUserChannel(USER_MATERIAL_CHANNEL_ROUGHNESS);

			if (!SGMaterial->HasUserChannel(USER_MATERIAL_CHANNEL_SPECULAR))
				SGMaterial->AddUserChannel(USER_MATERIAL_CHANNEL_SPECULAR);


			SGMaterial->SetName(TCHAR_TO_ANSI(*FString::Printf(TEXT("Material%d"), MaterialIndex)));

			// BaseColor
			if (FlattenMaterial.DiffuseSamples.Num())
			{
				SetMaterialChannelData(FlattenMaterial.DiffuseSamples, FlattenMaterial.DiffuseSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_DIFFUSE);
			}

			// Normal
			if (FlattenMaterial.NormalSamples.Num())
			{
				OutCastProperties.bCastNormals = true;
				SetMaterialChannelData(FlattenMaterial.NormalSamples, FlattenMaterial.NormalSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_NORMALS);
			}

			// Metallic
			if (FlattenMaterial.MetallicSamples.Num())
			{
				OutCastProperties.bCastMetallic = true;
				SetMaterialChannelData(FlattenMaterial.MetallicSamples, FlattenMaterial.MetallicSize, SGMaterial, USER_MATERIAL_CHANNEL_METALLIC);
			}

			// Roughness
			if (FlattenMaterial.RoughnessSamples.Num())
			{
				OutCastProperties.bCastRoughness = true;
				SetMaterialChannelData(FlattenMaterial.RoughnessSamples, FlattenMaterial.RoughnessSize, SGMaterial, USER_MATERIAL_CHANNEL_ROUGHNESS);
			}

			// Specular
			if (FlattenMaterial.SpecularSamples.Num())
			{
				OutCastProperties.bCastSpecular = true;
				SetMaterialChannelData(FlattenMaterial.SpecularSamples, FlattenMaterial.SpecularSize, SGMaterial, USER_MATERIAL_CHANNEL_SPECULAR);
			}

			OutSGMaterialTable->AddMaterial(SGMaterial);
		}

		return true;
	}

	void GetMaterialChannelData(const SimplygonSDK::spMaterial& InSGMaterial, const char* SGMaterialChannelName, TArray<FColor>& OutSamples, FIntPoint& OutTextureSize)
	{
		SimplygonSDK::spImageData SGChannelData = InSGMaterial->GetLayeredTextureImage(SGMaterialChannelName, 0);
		if (SGChannelData)
		{
			SimplygonSDK::spUnsignedCharArray ImageColors = SimplygonSDK::SafeCast<SimplygonSDK::IUnsignedCharArray>(SGChannelData->GetColors());

			OutTextureSize.X = SGChannelData->GetXSize();
			OutTextureSize.Y = SGChannelData->GetYSize();

			int32 TexelsCount = OutTextureSize.X*OutTextureSize.Y;
			OutSamples.Empty(TexelsCount);
			OutSamples.AddUninitialized(TexelsCount);

			SimplygonSDK::spUnsignedCharData sgImageCharData = SDK->CreateUnsignedCharData();
			for (int32 TexelIndex = 0; TexelIndex < TexelsCount; ++TexelIndex)
			{
				//uint8 ColorData[4];
				//ImageColors->GetTuple(TexelIndex, (unsigned char*)&ColorData);

				ImageColors->GetTuple(TexelIndex, sgImageCharData);
				uint8* ColorData = sgImageCharData->GetData();

				OutSamples[TexelIndex].R = ColorData[0];
				OutSamples[TexelIndex].G = ColorData[1];
				OutSamples[TexelIndex].B = ColorData[2];
				//@third party code BEGIN SIMPLYGON
				if (SGMaterialChannelName == SimplygonSDK::SG_MATERIAL_CHANNEL_DIFFUSE ||
					SGMaterialChannelName == SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR)
				{
					OutSamples[TexelIndex].A = ColorData[3];
				}
				else
				{
					OutSamples[TexelIndex].A = FColor::White.A;
				}
				//@third party code BEGIN SIMPLYGON
			}
		}
	}

	void CreateFlattenMaterialFromSGMaterial(
		SimplygonSDK::spMaterialTable& InSGMaterialTable,
		FFlattenMaterial& OutMaterial)
	{
		SimplygonSDK::spMaterial SGMaterial = InSGMaterialTable->GetMaterial(0);

		// Diffuse
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_DIFFUSE, OutMaterial.DiffuseSamples, OutMaterial.DiffuseSize);

		// Normal
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_NORMALS, OutMaterial.NormalSamples, OutMaterial.NormalSize);

		// Metallic
		GetMaterialChannelData(SGMaterial, USER_MATERIAL_CHANNEL_METALLIC, OutMaterial.MetallicSamples, OutMaterial.MetallicSize);

		// Roughness
		GetMaterialChannelData(SGMaterial, USER_MATERIAL_CHANNEL_ROUGHNESS, OutMaterial.RoughnessSamples, OutMaterial.RoughnessSize);

		// Specular
		GetMaterialChannelData(SGMaterial, USER_MATERIAL_CHANNEL_SPECULAR, OutMaterial.SpecularSamples, OutMaterial.SpecularSize);
	}

	static FIntPoint ComputeMappingImageSize(const FMaterialSimplificationSettings& Settings)
	{
		FIntPoint ImageSize = Settings.BaseColorMapSize;
		ImageSize = ImageSize.ComponentMax(Settings.NormalMapSize);
		ImageSize = ImageSize.ComponentMax(Settings.MetallicMapSize);
		ImageSize = ImageSize.ComponentMax(Settings.RoughnessMapSize);
		ImageSize = ImageSize.ComponentMax(Settings.SpecularMapSize);
		return ImageSize;
	}

	//@third party code BEGIN SIMPLYGON
	bool CreateSGMaterialFromFlattenMaterial(
		const TIndirectArray<FFlattenMaterial>& InputMaterials,
		const FSimplygonMaterialLODSettings& InMaterialLODSettings,
		SimplygonSDK::spMaterialTable& OutSGMaterialTable,
		bool bReleaseInputMaterials)
	{
		if (InputMaterials.Num() == 0)
		{
			//If there are no materials, feed Simplygon with a default material instead.
			UE_LOG(LogSimplygon, Log, TEXT("Input meshes do not contain any materials. A proxy without material will be generated."));
			return false;
		}

		for (int32 MaterialIndex = 0; MaterialIndex < InputMaterials.Num(); MaterialIndex++)
		{
			SimplygonSDK::spMaterial SGMaterial = SDK->CreateMaterial();
			const FFlattenMaterial& FlattenMaterial = InputMaterials[MaterialIndex];

#if USE_USER_OPACITY_CHANNEL
			if (!SGMaterial->HasUserChannel(USER_MATERIAL_CHANNEL_OPACITY))
				SGMaterial->AddUserChannel(USER_MATERIAL_CHANNEL_OPACITY);
#endif
			if (!SGMaterial->HasUserChannel(USER_MATERIAL_CHANNEL_AO))
				SGMaterial->AddUserChannel(USER_MATERIAL_CHANNEL_AO);

			SGMaterial->SetName(TCHAR_TO_ANSI(*FString::Printf(TEXT("Material%d"), MaterialIndex)));

			// Does current material have BaseColor?
			if (FlattenMaterial.DiffuseSamples.Num())
			{
				if (InMaterialLODSettings.ChannelsToCast[0].bBakeVertexColors)
				{
					SGMaterial->SetVertexColorChannel(SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR, 0);
				}

				SetMaterialChannelData(FlattenMaterial.DiffuseSamples, FlattenMaterial.DiffuseSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR);
			}

			// Does current material have Metallic?
			if (FlattenMaterial.MetallicSamples.Num())
			{
				SetMaterialChannelData(FlattenMaterial.MetallicSamples, FlattenMaterial.MetallicSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_METALLIC);
			}

			// Does current material have Specular?
			if (FlattenMaterial.SpecularSamples.Num())
			{
				SetMaterialChannelData(FlattenMaterial.SpecularSamples, FlattenMaterial.SpecularSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_SPECULAR);
			}

			// Does current material have Roughness?
			if (FlattenMaterial.RoughnessSamples.Num())
			{
				SetMaterialChannelData(FlattenMaterial.RoughnessSamples, FlattenMaterial.RoughnessSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_ROUGHNESS);
			}

			//Does current material have a normalmap?
			if (FlattenMaterial.NormalSamples.Num())
			{
				SetMaterialChannelData(FlattenMaterial.NormalSamples, FlattenMaterial.NormalSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_NORMALS);
			}

			// Does current material have Opacity?
			if (FlattenMaterial.OpacitySamples.Num())
			{
#if USE_USER_OPACITY_CHANNEL
				SetMaterialChannelData(FlattenMaterial.OpacitySamples, FlattenMaterial.OpacitySize, SGMaterial, USER_MATERIAL_CHANNEL_OPACITY);
#else
				SetMaterialChannelData(FlattenMaterial.OpacitySamples, FlattenMaterial.OpacitySize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_OPACITY);
#endif
			}

			// Does current material have Emissive?
			if (FlattenMaterial.EmissiveSamples.Num())
			{
				SetMaterialChannelData(FlattenMaterial.EmissiveSamples, FlattenMaterial.EmissiveSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_EMISSIVE);
			}
			else
			{
				TArray<FColor> BlackEmissive;
				BlackEmissive.AddZeroed(1);
				SetMaterialChannelData(BlackEmissive, FlattenMaterial.EmissiveSize, SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_EMISSIVE);
			}

			// Does current material have Ambient Occlusion?
			if (FlattenMaterial.AOSamples.Num())
			{
				SetMaterialChannelData(FlattenMaterial.AOSamples, FlattenMaterial.AOSize, SGMaterial, USER_MATERIAL_CHANNEL_AO);
			}

			OutSGMaterialTable->AddMaterial(SGMaterial);

			if (bReleaseInputMaterials)
			{
				// Release FlattenMaterial. Using const_cast here to avoid removal of "const" from input data here
				// and above the call chain.
				const_cast<FFlattenMaterial*>(&FlattenMaterial)->ReleaseData();
			}
		}

		return true;
	}

	void SimplygonProcessLOD(
		SimplygonSDK::spReductionProcessor Processor,
		const FMeshMaterialReductionData& Data,
		const FSimplygonMaterialLODSettings& MaterialLODSettings,
		bool bIsSkeletal,
		TIndirectArray<FFlattenMaterial>& OutMaterials)
	{
		if (!MaterialLODSettings.bActive)
		{
			UE_LOG(LogSimplygon, Log, TEXT("Processing with %s."), *FString(Processor->GetClass()));
			Processor->RunProcessing();
			UE_LOG(LogSimplygon, Log, TEXT("Processing done."));
			return;
		}

		// Setup the mapping image used for casting
		SetupMappingImage(
			MaterialLODSettings,
			Processor->GetMappingImageSettings(),
			/*InAggregateProcess = */ false,
			/*InRemoveUVs = */ false,
			&Data);

		// Convert FFlattenMaterial array to Simplygon materials
		SimplygonSDK::spMaterialTable InputMaterialTable = SDK->CreateMaterialTable();
		// Convert and keep FFlattenMaterial. There's no point of releasing it here - this conversion is short-term.
		CreateSGMaterialFromFlattenMaterial(Data.FlattenMaterials, MaterialLODSettings, InputMaterialTable, false);

		// Perform LOD processing
		UE_LOG(LogSimplygon, Log, TEXT("Processing with %s."), *FString(Processor->GetClass()));
		Processor->RunProcessing();
		UE_LOG(LogSimplygon, Log, TEXT("Processing done."));

		// Cast input materials to output materials and convert to FFlattenMaterial
		UE_LOG(LogSimplygon, Log, TEXT("Casting materials."));
		OutMaterials.Empty();
		for (int32 OutMaterialIndex = 0; OutMaterialIndex < Data.GetOutputMaterialCount(); OutMaterialIndex++)
		{
			// Read material from Simplygon
			SimplygonSDK::spMappingImage MappingImage = Processor->GetMappingImage(OutMaterialIndex);
			SimplygonSDK::spMaterial SgMaterial = RebakeMaterials(MaterialLODSettings, MappingImage, InputMaterialTable, OutMaterialIndex);
			FFlattenMaterial* OutMaterial = new (OutMaterials) FFlattenMaterial;
			CreateFlattenMaterialFromSGMaterial(SgMaterial, *OutMaterial);
			// Try to optimize material.
			SimplygonSDK::spSceneNode RootNode = Processor->GetScene()->GetRootNode();
			SimplygonSDK::spSceneMesh ReducedMesh = GetSceneMesh(RootNode);
			OptimizeFlattenMaterialForGeometry(*OutMaterial, ReducedMesh->GetGeometry(), OutMaterialIndex);
			// Setup remaining data
			OutMaterial->BlendMode = Data.OutputBlendMode[OutMaterialIndex];
			OutMaterial->bTwoSided = Data.OutputTwoSided[OutMaterialIndex];
			OutMaterial->EmissiveScale = Data.OutputEmissiveScale[OutMaterialIndex];
		}
		UE_LOG(LogSimplygon, Log, TEXT("Casting done."));
	}

	// Processor is spRemeshingProcessor or spAggregationProcessor
	template <typename ProcessorClass>
	void SimplygonProcessMassiveLOD(
		ProcessorClass Processor,
		const TArray<FMeshMaterialReductionData*>& DataArray,
		const FSimplygonMaterialLODSettings& MaterialLODSettings,
		FFlattenMaterial& OutMaterial)
	{
		if (!MaterialLODSettings.bActive)
		{
			UE_LOG(LogSimplygon, Log, TEXT("Processing with %s."), *FString(Processor->GetClass()));
			Processor->RunProcessing();
			UE_LOG(LogSimplygon, Log, TEXT("Processing done."));
			return;
		}

		// Setup the mapping image used for casting
		SetupMappingImage(
			MaterialLODSettings,
			Processor->GetMappingImageSettings(),
			/*InAggregateProcess = */ TAreTypesEqual<ProcessorClass, SimplygonSDK::spAggregationProcessor>::Value,
			/*InRemoveUVs = */ true,
			nullptr);

		// Convert FFlattenMaterial array to Simplygon materials
		SimplygonSDK::spMaterialTable InputMaterialTable = SDK->CreateMaterialTable();
		for (int32 MeshIndex = 0; MeshIndex < DataArray.Num(); MeshIndex++)
		{
			// For some cases, MassiveLOD will have all materials baked in DataArray[0]
			if (DataArray[MeshIndex]->FlattenMaterials.Num())
			{
				// Convert and immediately release FFlattenMaterial. It's worth releasing input materials if MassiveLOD converts
				// really big scenes.
				CreateSGMaterialFromFlattenMaterial(DataArray[MeshIndex]->FlattenMaterials, MaterialLODSettings, InputMaterialTable, true);
			}
		}

		// Perform LOD processing
		UE_LOG(LogSimplygon, Log, TEXT("Processing with %s."), *FString(Processor->GetClass()));
		Processor->RunProcessing();
		UE_LOG(LogSimplygon, Log, TEXT("Processing done."));

		// Cast input materials to output materials and convert to FFlattenMaterial
		UE_LOG(LogSimplygon, Log, TEXT("Casting materials."));
		SimplygonSDK::spMappingImage MappingImage = Processor->GetMappingImage();
		SimplygonSDK::spMaterial SgMaterial = RebakeMaterials(MaterialLODSettings, MappingImage, InputMaterialTable);
		CreateFlattenMaterialFromSGMaterial(SgMaterial, OutMaterial);

		// Try to optimize material.
		SimplygonSDK::spSceneNode RootNode = Processor->GetScene()->GetRootNode();
		SimplygonSDK::spSceneMesh ReducedMesh = GetSceneMesh(RootNode);
		OptimizeFlattenMaterialForGeometry(OutMaterial, ReducedMesh->GetGeometry());
		// Setup remaining data.
		// Use OutputBlendMode[0] from DataArray[0], as prepared by GenerateMassiveLODMesh function.
		OutMaterial.BlendMode = DataArray[0]->OutputBlendMode[0];
		OutMaterial.bTwoSided = DataArray[0]->OutputTwoSided[0];
		OutMaterial.EmissiveScale = DataArray[0]->OutputEmissiveScale[0];
		UE_LOG(LogSimplygon, Log, TEXT("Casting done."));
	}

	void CreateFlattenMaterialFromSGMaterial(
		SimplygonSDK::spMaterial& SGMaterial,
		FFlattenMaterial& OutMaterial)
	{
		// Diffuse
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_BASECOLOR, OutMaterial.DiffuseSamples, OutMaterial.DiffuseSize);

		// Normal
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_NORMALS, OutMaterial.NormalSamples, OutMaterial.NormalSize);

		// Metallic
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_METALLIC, OutMaterial.MetallicSamples, OutMaterial.MetallicSize);

		// Roughness
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_ROUGHNESS, OutMaterial.RoughnessSamples, OutMaterial.RoughnessSize);

		// Specular
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_SPECULAR, OutMaterial.SpecularSamples, OutMaterial.SpecularSize);

		// Opacity
#if USE_USER_OPACITY_CHANNEL
		GetMaterialChannelData(SGMaterial, USER_MATERIAL_CHANNEL_OPACITY, OutMaterial.OpacitySamples, OutMaterial.OpacitySize);
#else
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_OPACITY, OutMaterial.OpacitySamples, OutMaterial.OpacitySize);
#endif

		// Emissive
		GetMaterialChannelData(SGMaterial, SimplygonSDK::SG_MATERIAL_CHANNEL_EMISSIVE, OutMaterial.EmissiveSamples, OutMaterial.EmissiveSize);

		// Ambient Occlusion
		GetMaterialChannelData(SGMaterial, USER_MATERIAL_CHANNEL_AO, OutMaterial.AOSamples, OutMaterial.AOSize);
	}

	void OptimizeFlattenMaterialForGeometry(FFlattenMaterial& Material, const SimplygonSDK::spGeometryData& GeometryData, int32 MaterialIndex = -1)
	{
		if (GeometryData == nullptr)
		{
			return;
		}

		// Extract UV from geometry
		SimplygonSDK::spRealArray sgTexCoords = GeometryData->GetTexCoords(0);
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		if (!sgTexCoords)
		{
			return; // shouldn't happen
		}

		int32 NumTris = GeometryData->GetTriangleCount();
		int32 NumWedges = NumTris * 3;

		TArray<FVector2D> TexCoords;
		TexCoords.AddZeroed(NumWedges);
		TArray<int32> FaceMaterialIndices;
		FaceMaterialIndices.AddZeroed(NumTris);

		SimplygonSDK::spRealData sgTuple = SDK->CreateRealData();

		if (MaterialIndices)
		{
			for (int32 TriIndex = 0; TriIndex < NumTris; TriIndex++)
			{
				FaceMaterialIndices[TriIndex] = MaterialIndices->GetItem(TriIndex);
			}
		}

		for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; WedgeIndex++)
		{
			if (MaterialIndex >= 0)
			{
				int32 FaceIndex = WedgeIndex / 3;
				if (FaceMaterialIndices[FaceIndex] != MaterialIndex)
				{
					continue;
				}
			}

			sgTexCoords->GetTuple(WedgeIndex, sgTuple);
			SimplygonSDK::real* sgCoord = sgTuple->GetData();
			TexCoords[WedgeIndex] = FVector2D(sgCoord[0], sgCoord[1]);
		}

		if (TexCoords.Num())
		{
			IMeshUtilities& MeshUtilities = FModuleManager::Get().LoadModuleChecked<IMeshUtilities>("MeshUtilities");
			ISimplygonUtilities* SimplygonUtilities = MeshUtilities.GetSimplygonUtilitiesInterface();
			check(SimplygonUtilities);
			SimplygonUtilities->OptimizeFlattenMaterialForUV(Material, TexCoords);
		}
	}

	SimplygonSDK::spSceneMesh GetSceneMesh(const SimplygonSDK::spSceneNode& RootNode)
	{
		SimplygonSDK::spSceneMesh ReturnMesh;
		int32 NodeCount = RootNode->GetChildCount();
		for (int32 NodeIndex = 0; NodeIndex < NodeCount; ++NodeIndex)
		{
			//Assumes that the first SceneMesh in Scene is the processed mesh we want
			if (RootNode->GetChild(NodeIndex)->IsA("ISceneMesh"))
			{
				ReturnMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>(RootNode->GetChild(NodeIndex));
				break;
			}
		}

		return ReturnMesh;
	}

	void CreateRawMeshFromGeometry_Proxy(FRawMesh& OutRawMesh,
		const SimplygonSDK::spGeometryData& GeometryData,
		EWindingMode WindingMode)
	{
		check(GeometryData);

		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		SimplygonSDK::spRidArray GroupIds = GeometryData->GetGroupIds();
		SimplygonSDK::spRealArray LinearColors = GeometryData->GetColors(0);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);

		SimplygonSDK::spRealData sgTuple = SDK->CreateRealData();

		check(Positions);
		check(Indices);

		FRawMesh& RawMesh = OutRawMesh;
		const bool bReverseWinding = (WindingMode == WINDING_Reverse);
		int32 NumTris = GeometryData->GetTriangleCount();
		int32 NumWedges = NumTris * 3;
		int32 NumVertices = GeometryData->GetVertexCount();

		RawMesh.VertexPositions.Empty(NumVertices);
		RawMesh.VertexPositions.AddUninitialized(NumVertices);
		for (int32 VertexIndex = 0; VertexIndex < NumVertices; ++VertexIndex)
		{
			//Positions->GetTuple(VertexIndex, (float*)&RawMesh.VertexPositions[VertexIndex]);
			Positions->GetTuple(VertexIndex, sgTuple);
			SimplygonSDK::real* vertexPos = sgTuple->GetData();
			RawMesh.VertexPositions[VertexIndex] = GetConversionMatrix().TransformPosition(FVector(vertexPos[0], vertexPos[1], vertexPos[2]));
		}

		RawMesh.WedgeIndices.Empty(NumWedges);
		RawMesh.WedgeIndices.AddUninitialized(NumWedges);
		for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
		{

			for (int32 CornerIndex = 0; CornerIndex < 3; ++CornerIndex)
			{
				const uint32 DestIndex = bReverseWinding ? (2 - CornerIndex) : CornerIndex;
				RawMesh.WedgeIndices[TriIndex * 3 + DestIndex] = Indices->GetItem(TriIndex * 3 + CornerIndex);
			}

		}

		for (int32 TexCoordIndex = 0; TexCoordIndex < MAX_MESH_TEXTURE_COORDS; ++TexCoordIndex)
		{
			SimplygonSDK::spRealArray TexCoords = GeometryData->GetTexCoords(TexCoordIndex);
			if (TexCoords)
			{
				RawMesh.WedgeTexCoords[TexCoordIndex].Empty(NumWedges);
				RawMesh.WedgeTexCoords[TexCoordIndex].AddUninitialized(NumWedges);
				for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
				{
					for (int32 CornerIndex = 0; CornerIndex < 3; ++CornerIndex)
					{
						const uint32 DestIndex = bReverseWinding ? (2 - CornerIndex) : CornerIndex;
						//TexCoords->GetTuple(TriIndex * 3 + CornerIndex, (float*)&RawMesh.WedgeTexCoords[TexCoordIndex][TriIndex * 3 + DestIndex]);
						TexCoords->GetTuple(TriIndex * 3 + CornerIndex, sgTuple);

						SimplygonSDK::real* sgTextCoors = sgTuple->GetData();
						RawMesh.WedgeTexCoords[TexCoordIndex][TriIndex * 3 + DestIndex] = FVector2D(sgTextCoors[0], sgTextCoors[1]);
					}

				}
			}
		}

		if (LinearColors)
		{
			RawMesh.WedgeColors.Empty(NumWedges);
			RawMesh.WedgeColors.AddUninitialized(NumWedges);
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				//LinearColors->GetTuple(WedgeIndex, (float*)&LinearColor);
				LinearColors->GetTuple(WedgeIndex, sgTuple);
				SimplygonSDK::real* sgVertexColor = sgTuple->GetData();
				FLinearColor LinearColor(sgVertexColor[0], sgVertexColor[1], sgVertexColor[2], sgVertexColor[3]);
				RawMesh.WedgeColors[WedgeIndex] = LinearColor.ToFColor(true);
			}
		}

		if (Normals)
		{
			if (Tangents && Bitangents)
			{
				RawMesh.WedgeTangentX.Empty(NumWedges);
				RawMesh.WedgeTangentX.AddUninitialized(NumWedges);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					//Tangents->GetTuple(WedgeIndex, (float*)&RawMesh.WedgeTangentX[WedgeIndex]);
					Tangents->GetTuple(WedgeIndex, sgTuple);
					SimplygonSDK::real* sgTangents = sgTuple->GetData();
					RawMesh.WedgeTangentX[WedgeIndex] = GetConversionMatrix().TransformPosition(FVector(sgTangents[0], sgTangents[1], sgTangents[2]));
				}

				RawMesh.WedgeTangentY.Empty(NumWedges);
				RawMesh.WedgeTangentY.AddUninitialized(NumWedges);
				for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
				{
					//Bitangents->GetTuple(WedgeIndex, (float*)&RawMesh.WedgeTangentY[WedgeIndex]);
					Bitangents->GetTuple(WedgeIndex, sgTuple);
					SimplygonSDK::real* sgBitangents = sgTuple->GetData();
					RawMesh.WedgeTangentY[WedgeIndex] = GetConversionMatrix().TransformPosition(FVector(sgBitangents[0], sgBitangents[1], sgBitangents[2]));
				}
			}

			RawMesh.WedgeTangentZ.Empty(NumWedges);
			RawMesh.WedgeTangentZ.AddUninitialized(NumWedges);
			for (int32 WedgeIndex = 0; WedgeIndex < NumWedges; ++WedgeIndex)
			{
				//Normals->GetTuple(WedgeIndex, (float*)&RawMesh.WedgeTangentZ[WedgeIndex]);
				Normals->GetTuple(WedgeIndex, sgTuple);
				SimplygonSDK::real* sgNormal = sgTuple->GetData();
				RawMesh.WedgeTangentZ[WedgeIndex] = GetConversionMatrix().TransformPosition(FVector(sgNormal[0], sgNormal[1], sgNormal[2]));
			}
		}

		RawMesh.FaceMaterialIndices.Empty(NumTris);
		RawMesh.FaceMaterialIndices.AddZeroed(NumTris);
		if (MaterialIndices)
		{
			for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
			{
				/*This is hard-coded to zero for now, but should be changed when ProxyLOD
				supports multiple materials.
				*/
				RawMesh.FaceMaterialIndices[TriIndex] = 0;//MaterialIndices->GetItem(TriIndex);
			}
		}

		//Default Smoothing
		RawMesh.FaceSmoothingMasks.Empty(NumTris);
		RawMesh.FaceSmoothingMasks.AddZeroed(NumTris);
		for (int32 TriIndex = 0; TriIndex < NumTris; ++TriIndex)
		{
			RawMesh.FaceSmoothingMasks[TriIndex] = 1;
		}
	}

	/**
	* The method converts ESimplygonTextureSamplingQuality
	* @param InSamplingQuality - The Caster Settings used to setup the Simplygon Caster.
	* @param InMappingImage - Simplygon MappingImage.
	* @result
	*/
	uint8 GetSamples(ESimplygonTextureSamplingQuality::Type InSamplingQuality)
	{
		switch (InSamplingQuality)
		{
		case ESimplygonTextureSamplingQuality::Poor:
			return 1;
		case ESimplygonTextureSamplingQuality::Low:
			return 2;
		case ESimplygonTextureSamplingQuality::Medium:
			return 6;
		case ESimplygonTextureSamplingQuality::High:
			return 8;
		}
		return 1;
	}

	uint8 ConvertColorChannelToInt(ESimplygonColorChannels::Type InSamplingQuality)
	{
		switch (InSamplingQuality)
		{
		case ESimplygonColorChannels::RGBA:
			return 4;
		case ESimplygonColorChannels::RGB:
			return 3;
		case ESimplygonColorChannels::L:
			return 1;
		}

		return 3;
	}

	/**
	* Use Simplygon Color Caster to Cast a Color Channel
	* @param InCasterSettings - The Caster Settings used to setup the Simplygon Caster.
	* @param InMappingImage - Simplygon MappingImage.
	* @param InMaterialTable - Input MaterialTable used by the Simplygon Caster.
	* @param InTextureTable - Simplygon TextureTable used by the Simplyogn Caster.
	* @param OutColorData - The Simplygon Output ImageData.
	*/
	void CastColorChannel(const FSimplygonChannelCastingSettings& InCasterSettings,
		SimplygonSDK::spMappingImage& InMappingImage,
		SimplygonSDK::spMaterialTable& InMaterialTable,
		//SimplygonSDK::spTextureTable& InTextureTable,
		SimplygonSDK::spImageData& OutColorData)
	{
		SimplygonSDK::spColorCaster cast = SDK->CreateColorCaster();

		cast->SetColorType(GetSimplygonMaterialChannel(InCasterSettings.MaterialChannel));
		cast->SetSourceMaterials(InMaterialTable);
		//cast->SetSourceTextures(InTextureTable);
		cast->SetMappingImage(InMappingImage); // The mapping image we got from the remeshing process.
		cast->SetOutputChannels(ConvertColorChannelToInt(InCasterSettings.ColorChannels)); // RGB, 3 channels! (1 would be for grey scale, and 4 would be for RGBA.)
		cast->SetOutputChannelBitDepth(InCasterSettings.BitsPerChannel); // 8 bits per channel. So in this case we will have 24bit colors RGB.
		cast->SetDilation(10); // To avoid mip-map artifacts, the empty pixels on the map needs to be filled to a degree aswell.
		cast->SetOutputImage(OutColorData);
		cast->SetBakeOpacityInAlpha(false);
		//cast->SetBakeVertexColors(InCasterSettings.bBakeVertexColors);
		cast->SetIsSRGB(InCasterSettings.bUseSRGB);
		cast->CastMaterials(); // Fetch!

	}

	/**
	* Use Simplygon Normal Caster to Cast a Normals Channel
	* @param InCasterSettings - The Caster Settings used to setup the Simplygon Caster.
	* @param InMappingImage - Simplygon MappingImage.
	* @param InMaterialTable - Input MaterialTable used by the Simplygon Caster.
	* @param InTextureTable - Simplygon TextureTable used by the Simplyogn Caster.
	* @param OutColorData - The Simplygon Output ImageData.
	*/
	void CastNormalsChannel(FSimplygonChannelCastingSettings InCasterSettings,
		SimplygonSDK::spMappingImage& InMappingImage,
		SimplygonSDK::spMaterialTable& InMaterialTable,
		//SimplygonSDK::spTextureTable& InTextureTable,
		SimplygonSDK::spImageData& OutColorData,
		int32 DestinationMaterialIndex = -1)
	{
		SimplygonSDK::spNormalCaster cast = SDK->CreateNormalCaster();
		cast->SetSourceMaterials(InMaterialTable);
		//cast->SetSourceTextures(InTextureTable);
		cast->SetMappingImage(InMappingImage); // The mapping image we got from the remeshing process.
		cast->SetOutputChannels(ConvertColorChannelToInt(InCasterSettings.ColorChannels)); // RGB, 3 channels! (1 would be for grey scale, and 4 would be for RGBA.)
		cast->SetOutputChannelBitDepth(8); // 8 bits per channel. So in this case we will have 24bit colors RGB.
		cast->SetDilation(10); // To avoid mip-map artifacts, the empty pixels on the map needs to be filled to a degree aswell.
		cast->SetFlipBackfacingNormals(InCasterSettings.bFlipBackfacingNormals);
		cast->SetGenerateTangentSpaceNormals(InCasterSettings.bUseTangentSpaceNormals);
		cast->SetFlipGreen(false);
		//cast->SetNormalMapTextureLevel();
		cast->SetDestMaterialId(DestinationMaterialIndex);
		cast->SetOutputImage(OutColorData);
		cast->CastMaterials(); // Fetch!
	}


	/**
	* Use Simplygon Opacity Caster to Cast an Opacity Channel
	* @param InCasterSettings - The Caster Settings used to setup the Simplygon Caster.
	* @param InMappingImage - Simplygon MappingImage.
	* @param InMaterialTable - Input MaterialTable used by the Simplygon Caster.
	* @param InTextureTable - Simplygon TextureTable used by the Simplyogn Caster.
	* @param OutColorData - The Simplygon Output ImageData.
	*/
	void CastOpacityChannel(FSimplygonChannelCastingSettings InCasterSettings,
		SimplygonSDK::spMappingImage& InMappingImage,
		SimplygonSDK::spMaterialTable& InMaterialTable,
		//SimplygonSDK::spTextureTable& InTextureTable,
		SimplygonSDK::spImageData& OutColorData)
	{
		SimplygonSDK::spOpacityCaster cast = SDK->CreateOpacityCaster();
		cast->SetSourceMaterials(InMaterialTable);
		//cast->SetSourceTextures(InTextureTable);
		cast->SetMappingImage(InMappingImage); // The mapping image we got from the remeshing process.
		cast->SetOutputChannels(ConvertColorChannelToInt(InCasterSettings.ColorChannels)); // RGB, 3 channels! (1 would be for grey scale, and 4 would be for RGBA.)
		cast->SetOutputChannelBitDepth(8); // 8 bits per channel. So in this case we will have 24bit colors RGB.
		cast->SetDilation(10); // To avoid mip-map artifacts, the empty pixels on the map needs to be filled to a degree aswell.
		cast->SetOutputImage(OutColorData);
		cast->CastMaterials(); // Fetch!


	}


	/**
	* Sets Mapping Image Setting for Simplygon.
	* @param InMaterialLODSettings - The MaterialLOD Settings used for setting up Simplygon MappingImageSetting.
	* @param InMappingImageSettings - The Simplygon MappingImage Settings that is being setup.
	*/
	void SetupMappingImage(const FSimplygonMaterialLODSettings& InMaterialLODSettings,
		SimplygonSDK::spMappingImageSettings InMappingImageSettings,
		bool InAggregateProcess,
		bool InRemoveUVs,
		const FMeshMaterialReductionData* ReductionData)
	{
		if (!InMaterialLODSettings.bActive)
		{
			return;
		}

		int32 NumInputMaterials = 1;
		int32 NumOutputMaterials = 1;
		if (ReductionData)
		{
			NumInputMaterials = ReductionData->GetInputMaterialCount();
			NumOutputMaterials = ReductionData->GetOutputMaterialCount();
			if (NumOutputMaterials > 1)
			{
				// The following code is required only if we're generating multiple materials.
				// Setup additional MappingImageSettings.
				InMappingImageSettings->SetInputMaterialCount(NumInputMaterials);
				InMappingImageSettings->SetOutputMaterialCount(NumOutputMaterials);
				for (int32 MaterialIndex = 0; MaterialIndex < NumInputMaterials; MaterialIndex++)
				{
					int32 OutMaterialIndex = ReductionData->OutputMaterialMap[MaterialIndex];
					InMappingImageSettings->SetInputOutputMaterialMapping(MaterialIndex, OutMaterialIndex);
				}
			}
		}

		//if (InMaterialLODSettings.bReuseExistingCharts || InAggregateProcess) - we're always using UVs from the mesh because new UVs are already generated with GenerateUniqueUVs() call
		if (InAggregateProcess || NumOutputMaterials > 1)
		{
			InMappingImageSettings->SetTexCoordGeneratorType(SimplygonSDK::SG_TEXCOORDGENERATORTYPE_CHARTAGGREGATOR);
			InMappingImageSettings->SetChartAggregatorMode(SimplygonSDK::SG_CHARTAGGREGATORMODE_SURFACEAREA);
		}
		else
		{
			InMappingImageSettings->SetTexCoordGeneratorType(SimplygonSDK::SG_TEXCOORDGENERATORTYPE_PARAMETERIZER);
		}

		InMappingImageSettings->SetGenerateMappingImage(true);
		InMappingImageSettings->SetTexCoordLevel(0);
		if (NumOutputMaterials > 1)
		{
			InMappingImageSettings->SetGenerateTexCoords(true);	//! check if it is possible to avoid this
		}


		for (int32 MaterialIndex = 0; MaterialIndex < NumOutputMaterials; MaterialIndex++)
		{
			InMappingImageSettings->SetGutterSpace(MaterialIndex, InMaterialLODSettings.GutterSpace);
			InMappingImageSettings->SetMultisamplingLevel(MaterialIndex, GetSamples(InMaterialLODSettings.SamplingQuality));
		}

		if (InRemoveUVs)
		{
			InMappingImageSettings->SetUseFullRetexturing(true);
		}

		InMappingImageSettings->SetGenerateTangents(false);

		bool bAutomaticSizes = InMaterialLODSettings.bUseAutomaticSizes;
		InMappingImageSettings->SetUseAutomaticTextureSize(bAutomaticSizes);

		if (!bAutomaticSizes)
		{
			for (int32 MaterialIndex = 0; MaterialIndex < NumOutputMaterials; MaterialIndex++)
			{
				InMappingImageSettings->SetWidth(MaterialIndex, InMaterialLODSettings.GetTextureResolutionFromEnum(InMaterialLODSettings.TextureWidth));
				InMappingImageSettings->SetHeight(MaterialIndex, InMaterialLODSettings.GetTextureResolutionFromEnum(InMaterialLODSettings.TextureHeight));
			}
		}
		else
		{
			InMappingImageSettings->SetForcePower2Texture(true);
		}
	}



	SimplygonSDK::spMaterial RebakeMaterials(const FSimplygonMaterialLODSettings& InMaterialLODSettings,
		SimplygonSDK::spMappingImage& InMappingImage,
		SimplygonSDK::spMaterialTable& InSGMaterialTable,
		int32 DestinationMaterialIndex = -1)
	{
		SimplygonSDK::spMaterial OutMaterial = SDK->CreateMaterial();
#if USE_USER_OPACITY_CHANNEL
		if (!OutMaterial->HasUserChannel(USER_MATERIAL_CHANNEL_OPACITY))
			OutMaterial->AddUserChannel(USER_MATERIAL_CHANNEL_OPACITY);
#endif
		if (!OutMaterial->HasUserChannel(USER_MATERIAL_CHANNEL_AO))
			OutMaterial->AddUserChannel(USER_MATERIAL_CHANNEL_AO);
		for (int ChannelIndex = 0; ChannelIndex < InMaterialLODSettings.ChannelsToCast.Num(); ChannelIndex++)
		{
			FSimplygonChannelCastingSettings CasterSetting = InMaterialLODSettings.ChannelsToCast[ChannelIndex];

			if (CasterSetting.bActive)
			{
				SimplygonSDK::spImageData OutColorData = SDK->CreateImageData();

				switch (CasterSetting.Caster)
				{
				case ESimplygonCasterType::Color:
					CastColorChannel(CasterSetting, InMappingImage, InSGMaterialTable, OutColorData);
					break;
				case ESimplygonCasterType::Normals:
					CastNormalsChannel(CasterSetting, InMappingImage, InSGMaterialTable, OutColorData, DestinationMaterialIndex);
					break;
				case ESimplygonCasterType::Opacity:
#if USE_USER_OPACITY_CHANNEL
					CastColorChannel(CasterSetting, InMappingImage, InSGMaterialTable, OutColorData);
#else
					CastOpacityChannel(CasterSetting, InMappingImage, InSGMaterialTable, OutColorData);
#endif
					break;
				default:
					break;
				}

				OutMaterial->SetLayeredTextureImage(GetSimplygonMaterialChannel(CasterSetting.MaterialChannel), 0, OutColorData);
				OutMaterial->SetLayeredTextureLevel(GetSimplygonMaterialChannel(CasterSetting.MaterialChannel), 0, 0);
			}
		}

		return OutMaterial;
	}


	/*
	*  (1, 0, 0)
	*  (0, 0, 1)
	*  (0, 1, 0)
	*/
	const FMatrix& GetConversionMatrix()
	{
		static FMatrix m;
		static bool bInitialized = false;
		if (!bInitialized)
		{
			m.SetIdentity();
			m.M[1][1] = 0.0f;
			m.M[2][1] = 1.0f;

			m.M[1][2] = 1.0f;
			m.M[2][2] = 0.0f;
			bInitialized = true;
		}

		return m;
	}

	void ValidateGeometry(SimplygonSDK::spGeometryValidator& GeometryValidator, SimplygonSDK::spGeometryData& GeometryData)
	{
		bool bGeometryValid = GeometryValidator->ValidateGeometry(GeometryData);
		if (!bGeometryValid)
		{
			uint32 error_val = GeometryValidator->GetErrorValue();
			if ((error_val & SimplygonSDK::SG_VALIDATIONERROR_ZERO_LENGTH_NORMAL) != 0)
			{
				SimplygonSDK::spNormalRepairer rep = SDK->CreateNormalRepairer();
				rep->SetRepairOnlyInvalidNormals(true);
				rep->SetGeometry(GeometryData);
				rep->RunProcessing();
			}
			else
			{
				FString ErrorMessage = ANSI_TO_TCHAR(GeometryValidator->GetErrorString());
				UE_LOG(LogSimplygon, Warning, TEXT("Invalid mesh data: %s."), *ErrorMessage);
			}
		}
	}
	//@third party code END SIMPLYGON
};

TScopedPointer<FSimplygonMeshReduction> GSimplygonMeshReduction;


void FSimplygonMeshReductionModule::StartupModule()
{
	GSimplygonMeshReduction = FSimplygonMeshReduction::Create();
}

void FSimplygonMeshReductionModule::ShutdownModule()
{
	FSimplygonMeshReduction::Destroy();
	GSimplygonMeshReduction = NULL;
}

IMeshReduction* FSimplygonMeshReductionModule::GetMeshReductionInterface()
{
	return GSimplygonMeshReduction;
}

IMeshMerging* FSimplygonMeshReductionModule::GetMeshMergingInterface()
{
	return GSimplygonMeshReduction;
}

//@third party code BEGIN SIMPLYGON 
IMeshMaterialReduction* FSimplygonMeshReductionModule::GetMeshMaterialReductionInterface()
{
	return GSimplygonMeshReduction;
}
//@third party code END SIMPLYGON


#undef LOCTEXT_NAMESPACE
